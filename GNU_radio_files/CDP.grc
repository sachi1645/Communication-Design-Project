options:
  parameters:
    author: ASUS
    catch_exceptions: 'True'
    category: '[GRC Hier Blocks]'
    cmake_opt: ''
    comment: ''
    copyright: ''
    description: ''
    gen_cmake: 'On'
    gen_linking: dynamic
    generate_options: qt_gui
    hier_block_src_path: '.:'
    id: CDP
    max_nouts: '0'
    output_language: python
    placement: (0,0)
    qt_qss_theme: ''
    realtime_scheduling: ''
    run: 'True'
    run_command: '{python} -u {filename}'
    run_options: prompt
    sizing_mode: fixed
    thread_safe_setters: ''
    title: Not titled yet
    window_size: (1000,1000)
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [8, 8]
    rotation: 0
    state: enabled

blocks:
- name: access_key
  id: variable
  parameters:
    comment: ''
    value: '''1110000101011010111010001001001111100001010110101110100010010011'''
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [488, 16.0]
    rotation: 0
    state: enabled
- name: aes_key
  id: variable
  parameters:
    comment: ''
    value: '''9F3C7A12D4E8B5C1A0F2D39B7E5648AF'''
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [456, 104.0]
    rotation: 0
    state: enabled
- name: dec_cc
  id: variable_cc_decoder_def
  parameters:
    comment: ''
    dim1: '1'
    dim2: '1'
    framebits: '2048'
    k: '7'
    mode: fec.CC_STREAMING
    ndim: '0'
    padding: 'False'
    polys: '[79,109]'
    rate: '2'
    state_end: '-1'
    state_start: '0'
    value: '"ok"'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1832, 16.0]
    rotation: 0
    state: enabled
- name: enc_cc
  id: variable_cc_encoder_def
  parameters:
    comment: ''
    dim1: '1'
    dim2: '1'
    framebits: '2048'
    k: '7'
    mode: fec.CC_STREAMING
    ndim: '0'
    padding: 'False'
    polys: '[79,109]'
    rate: '2'
    state_start: '0'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1616, 20.0]
    rotation: 0
    state: enabled
- name: excess_bw
  id: variable
  parameters:
    comment: ''
    value: '0.5'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [960, 16.0]
    rotation: 0
    state: enabled
- name: excess_bw_0
  id: variable
  parameters:
    comment: ''
    value: '0.5'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [944, 88.0]
    rotation: 0
    state: enabled
- name: freq
  id: variable_qtgui_range
  parameters:
    comment: ''
    gui_hint: ''
    label: Frequency Offset
    min_len: '200'
    orient: QtCore.Qt.Horizontal
    rangeType: float
    start: 1e-4
    step: 1e-2
    stop: 1e-3
    value: 5e-4
    widget: counter_slider
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1440, 160.0]
    rotation: 0
    state: enabled
- name: hdr_format
  id: variable
  parameters:
    comment: header_format_crc
    value: digital.header_format_default(access_key, 0)
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [320, 4.0]
    rotation: 0
    state: enabled
- name: hdr_format_0
  id: variable
  parameters:
    comment: header_format_crc
    value: digital.header_format_default(access_key, 0)
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [104, 88.0]
    rotation: 0
    state: enabled
- name: nfilts
  id: variable
  parameters:
    comment: ''
    value: '32'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1048, 16.0]
    rotation: 0
    state: enabled
- name: nfilts_0
  id: variable
  parameters:
    comment: ''
    value: '32'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1040, 88.0]
    rotation: 0
    state: enabled
- name: noise
  id: variable_qtgui_range
  parameters:
    comment: ''
    gui_hint: ''
    label: Noise
    min_len: '200'
    orient: QtCore.Qt.Horizontal
    rangeType: float
    start: '0.02'
    step: '0.05'
    stop: '0.22'
    value: '0.12'
    widget: counter_slider
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1264, 104.0]
    rotation: 0
    state: enabled
- name: phase_bw
  id: variable
  parameters:
    comment: ''
    value: '0.0628'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [872, 16.0]
    rotation: 0
    state: true
- name: phase_bw_0
  id: variable
  parameters:
    comment: ''
    value: '0.0628'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [848, 88.0]
    rotation: 0
    state: true
- name: qpsk
  id: variable_constellation_rect
  parameters:
    comment: ''
    const_points: '[0.707+0.707j, -0.707+0.707j, -0.707-0.707j, 0.707-0.707j]'
    imag_sect: '2'
    precision: '8'
    real_sect: '2'
    rot_sym: '4'
    soft_dec_lut: None
    sym_map: '[0, 1, 2, 3]'
    w_imag_sect: '1'
    w_real_sect: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [648, 16.0]
    rotation: 0
    state: enabled
- name: qpsk1
  id: variable_constellation_rect
  parameters:
    comment: ''
    const_points: '[0.707+0.707j, -0.707+0.707j, -0.707-0.707j, 0.707-0.707j]'
    imag_sect: '2'
    precision: '8'
    real_sect: '2'
    rot_sym: '4'
    soft_dec_lut: None
    sym_map: '[0, 1, 2, 3]'
    w_imag_sect: '1'
    w_real_sect: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1408, 16.0]
    rotation: 0
    state: enabled
- name: rrc_taps
  id: variable
  parameters:
    comment: ''
    value: firdes.root_raised_cosine(nfilts, nfilts, 1.0/float(sps), 0.35, 11*sps*nfilts)
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1112, 16.0]
    rotation: 0
    state: enabled
- name: rrc_taps_0
  id: variable
  parameters:
    comment: ''
    value: firdes.root_raised_cosine(nfilts, nfilts, 1.0/float(sps), 0.35, 11*sps*nfilts)
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1112, 88.0]
    rotation: 0
    state: enabled
- name: samp_rate
  id: variable
  parameters:
    comment: ''
    value: 600e3
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [200, 12]
    rotation: 0
    state: enabled
- name: sps
  id: variable
  parameters:
    comment: ''
    value: '4'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [808, 16.0]
    rotation: 0
    state: enabled
- name: sps_0
  id: variable
  parameters:
    comment: ''
    value: '4'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [368, 124.0]
    rotation: 0
    state: enabled
- name: variable_adaptive_algorithm_0
  id: variable_adaptive_algorithm
  parameters:
    comment: ''
    cons: qpsk
    delta: '10.0'
    ffactor: '0.99'
    modulus: '4'
    step_size: '.0001'
    type: cma
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1256, 16.0]
    rotation: 0
    state: true
- name: variable_adaptive_algorithm_0_0
  id: variable_adaptive_algorithm
  parameters:
    comment: ''
    cons: qpsk
    delta: '10.0'
    ffactor: '0.99'
    modulus: '4'
    step_size: '.0001'
    type: cma
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1088, 168.0]
    rotation: 0
    state: true
- name: blocks_char_to_float_0_0
  id: blocks_char_to_float
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    scale: '1'
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [416, 1048.0]
    rotation: 0
    state: enabled
- name: blocks_message_debug_0
  id: blocks_message_debug
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    en_uvec: 'True'
    log_level: info
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [880, 2080.0]
    rotation: 0
    state: enabled
- name: blocks_multiply_const_vxx_0
  id: blocks_multiply_const_vxx
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    const: '0.8'
    maxoutbuf: '0'
    minoutbuf: '0'
    type: complex
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [656, 512.0]
    rotation: 0
    state: enabled
- name: blocks_multiply_const_vxx_0_0
  id: blocks_multiply_const_vxx
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    const: '0.8'
    maxoutbuf: '0'
    minoutbuf: '0'
    type: complex
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [2712, 1056.0]
    rotation: 0
    state: enabled
- name: blocks_repack_bits_bb_0
  id: blocks_repack_bits_bb
  parameters:
    affinity: ''
    alias: ''
    align_output: 'False'
    comment: ''
    endianness: gr.GR_MSB_FIRST
    k: '1'
    l: '8'
    len_tag_key: '"packet_len"'
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [728, 1116.0]
    rotation: 0
    state: enabled
- name: blocks_repack_bits_bb_0_0
  id: blocks_repack_bits_bb
  parameters:
    affinity: ''
    alias: ''
    align_output: 'False'
    comment: ''
    endianness: gr.GR_MSB_FIRST
    k: '1'
    l: '8'
    len_tag_key: '"packet_len"'
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [912, 2040.0]
    rotation: 0
    state: enabled
- name: blocks_repack_bits_bb_1
  id: blocks_repack_bits_bb
  parameters:
    affinity: ''
    alias: ''
    align_output: 'False'
    comment: ''
    endianness: gr.GR_MSB_FIRST
    k: '8'
    l: '1'
    len_tag_key: '""'
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [56, 548.0]
    rotation: 0
    state: enabled
- name: blocks_repack_bits_bb_2
  id: blocks_repack_bits_bb
  parameters:
    affinity: ''
    alias: ''
    align_output: 'False'
    comment: ''
    endianness: gr.GR_MSB_FIRST
    k: '1'
    l: '8'
    len_tag_key: '""'
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [312, 572.0]
    rotation: 0
    state: enabled
- name: blocks_tagged_stream_mux_0
  id: blocks_tagged_stream_mux
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    lengthtagname: packet_len
    maxoutbuf: '0'
    minoutbuf: '0'
    ninputs: '2'
    tag_preserve_head_pos: '0'
    type: byte
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1312, 376.0]
    rotation: 0
    state: enabled
- name: blocks_tagged_stream_mux_0_0
  id: blocks_tagged_stream_mux
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    lengthtagname: packet_len
    maxoutbuf: '0'
    minoutbuf: '0'
    ninputs: '2'
    tag_preserve_head_pos: '0'
    type: byte
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [2192, 1128.0]
    rotation: 0
    state: enabled
- name: blocks_throttle2_0
  id: blocks_throttle2
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    ignoretag: 'True'
    limit: auto
    maximum: '0.1'
    maxoutbuf: '0'
    minoutbuf: '0'
    samples_per_second: samp_rate
    type: complex
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [2800, 1212.0]
    rotation: 0
    state: enabled
- name: blocks_throttle2_1
  id: blocks_throttle2
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    ignoretag: 'True'
    limit: auto
    maximum: '0.1'
    maxoutbuf: '0'
    minoutbuf: '0'
    samples_per_second: samp_rate
    type: complex
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [784, 468.0]
    rotation: 0
    state: enabled
- name: blocks_unpack_k_bits_bb_0_0
  id: blocks_unpack_k_bits_bb
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    k: '2'
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [368, 2080.0]
    rotation: 0
    state: enabled
- name: digital_constellation_decoder_cb_0_0
  id: digital_constellation_decoder_cb
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    constellation: qpsk
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [624, 1880.0]
    rotation: 0
    state: enabled
- name: digital_constellation_modulator_0
  id: digital_constellation_modulator
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    constellation: qpsk
    differential: 'False'
    excess_bw: '0.5'
    log: 'False'
    maxoutbuf: '0'
    minoutbuf: '0'
    samples_per_symbol: '4'
    truncate: 'False'
    verbose: 'False'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [352, 464.0]
    rotation: 0
    state: enabled
- name: digital_constellation_modulator_0_0
  id: digital_constellation_modulator
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    constellation: qpsk
    differential: 'True'
    excess_bw: '0.5'
    log: 'False'
    maxoutbuf: '0'
    minoutbuf: '0'
    samples_per_symbol: '4'
    truncate: 'False'
    verbose: 'False'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [2456, 1088.0]
    rotation: 0
    state: enabled
- name: digital_constellation_soft_decoder_cf_0
  id: digital_constellation_soft_decoder_cf
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    constellation: qpsk
    maxoutbuf: '0'
    minoutbuf: '0'
    npwr: '-1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [664, 948.0]
    rotation: 0
    state: enabled
- name: digital_correlate_access_code_xx_ts_0
  id: digital_correlate_access_code_xx_ts
  parameters:
    access_code: access_key
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    tagname: packet_len
    threshold: '2'
    type: byte
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [392, 1168.0]
    rotation: 0
    state: enabled
- name: digital_correlate_access_code_xx_ts_0_0
  id: digital_correlate_access_code_xx_ts
  parameters:
    access_code: access_key
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    tagname: packet_len
    threshold: '2'
    type: byte
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [616, 2056.0]
    rotation: 0
    state: enabled
- name: digital_costas_loop_cc_0
  id: digital_costas_loop_cc
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    order: '4'
    use_snr: 'False'
    w: phase_bw
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [296, 888.0]
    rotation: 0
    state: enabled
- name: digital_costas_loop_cc_0_0
  id: digital_costas_loop_cc
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    order: '4'
    use_snr: 'False'
    w: phase_bw_0
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [360, 1824.0]
    rotation: 0
    state: enabled
- name: digital_crc_append_0
  id: digital_crc_append
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    final_xor: '0xFFFFFFFF'
    initial_value: '0xFFFFFFFF'
    input_reflected: 'True'
    maxoutbuf: '0'
    minoutbuf: '0'
    num_bits: '32'
    poly: '0x4C11DB7'
    result_reflected: 'True'
    skip_header_bytes: '0'
    swap_endianness: 'False'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [576, 224.0]
    rotation: 0
    state: enabled
- name: digital_crc_append_0_0
  id: digital_crc_append
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    final_xor: '0xFFFFFFFF'
    initial_value: '0xFFFFFFFF'
    input_reflected: 'True'
    maxoutbuf: '0'
    minoutbuf: '0'
    num_bits: '32'
    poly: '0x4C11DB7'
    result_reflected: 'True'
    skip_header_bytes: '0'
    swap_endianness: 'False'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1144, 1256.0]
    rotation: 0
    state: enabled
- name: digital_descrambler_bb_0
  id: digital_descrambler_bb
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    len: '7'
    mask: '0x8A'
    maxoutbuf: '0'
    minoutbuf: '0'
    seed: '0x7F'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [240, 1156.0]
    rotation: 0
    state: enabled
- name: digital_diff_decoder_bb_0_0
  id: digital_diff_decoder_bb
  parameters:
    affinity: ''
    alias: ''
    coding: digital.DIFF_DIFFERENTIAL
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    modulus: '4'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [888, 1848.0]
    rotation: 0
    state: enabled
- name: digital_linear_equalizer_0
  id: digital_linear_equalizer
  parameters:
    adapt_after_training: 'True'
    affinity: ''
    alg: variable_adaptive_algorithm_0
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    num_taps: '15'
    sps: '2'
    training_sequence: '[ ]'
    training_start_tag: corr_est
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [792, 680.0]
    rotation: 0
    state: enabled
- name: digital_linear_equalizer_0_0
  id: digital_linear_equalizer
  parameters:
    adapt_after_training: 'True'
    affinity: ''
    alg: variable_adaptive_algorithm_0
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    num_taps: '15'
    sps: '2'
    training_sequence: '[ ]'
    training_start_tag: corr_est
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [864, 1488.0]
    rotation: 0
    state: enabled
- name: digital_map_bb_0_0
  id: digital_map_bb
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    map: '[0,1,2,3]'
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1152, 1848.0]
    rotation: 0
    state: enabled
- name: digital_protocol_formatter_async_0
  id: digital_protocol_formatter_async
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    format: hdr_format
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [744, 312.0]
    rotation: 0
    state: enabled
- name: digital_protocol_formatter_async_0_0
  id: digital_protocol_formatter_async
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    format: hdr_format
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1584, 1096.0]
    rotation: 0
    state: enabled
- name: digital_scrambler_bb_0
  id: digital_scrambler_bb
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    len: '7'
    mask: '0x8A'
    maxoutbuf: '0'
    minoutbuf: '0'
    seed: '0x7F'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [200, 492.0]
    rotation: 180
    state: enabled
- name: digital_symbol_sync_xx_0
  id: digital_symbol_sync_xx
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    constellation: digital.constellation_bpsk().base()
    damping: '1.0'
    loop_bw: phase_bw
    max_dev: '1.5'
    maxoutbuf: '0'
    minoutbuf: '0'
    nfilters: '128'
    osps: '2'
    pfb_mf_taps: '[]'
    resamp_type: digital.IR_MMSE_8TAP
    sps: sps
    ted_gain: '1.0'
    ted_type: digital.TED_SIGNAL_TIMES_SLOPE_ML
    type: cc
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [384, 596.0]
    rotation: 0
    state: enabled
- name: digital_symbol_sync_xx_0_0
  id: digital_symbol_sync_xx
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    constellation: digital.constellation_bpsk().base()
    damping: '1.0'
    loop_bw: phase_bw
    max_dev: '1.5'
    maxoutbuf: '0'
    minoutbuf: '0'
    nfilters: '128'
    osps: '2'
    pfb_mf_taps: '[]'
    resamp_type: digital.IR_MMSE_8TAP
    sps: sps
    ted_gain: '1.0'
    ted_type: digital.TED_SIGNAL_TIMES_SLOPE_ML
    type: cc
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [384, 1572.0]
    rotation: 0
    state: enabled
- name: epy_block_0_0
  id: epy_block
  parameters:
    _source_code: "from gnuradio import gr\nimport pmt\n\nclass add_address_block(gr.basic_block):\n\
      \    \"\"\"\n    Adds a fixed 32-byte PREAMBLE + 1-byte destination address\
      \ to each PDU.\n\n    Input  PDU format :\n        [ SEQ(1B) | PAYLOAD(32B)\
      \ | CRC32(4B) ]\n\n    Output PDU format :\n        [ PREAMBLE(32B) | DEST(1B)\
      \ | SEQ(1B) | PAYLOAD(32B) | CRC32(4B) ]\n\n    Parameters\n    ----------\n\
      \    address : int (0\u2013255)  Destination address\n    \"\"\"\n\n    def\
      \ __init__(self, address=1):\n        gr.basic_block.__init__(\n           \
      \ self,\n            name=\"Add Preamble + Address\",\n            in_sig=None,\n\
      \            out_sig=None\n        )\n\n        # Ensure address fits in 1 byte\n\
      \        self.address = int(address) & 0xFF\n\n        # ---- FIXED 32-BYTE\
      \ PREAMBLE HERE ----\n        self.preamble = [\n            0xD3, 0x42, 0xA1,\
      \ 0x7F, 0x9C, 0xE2, 0x55, 0xAA,\n            0x13, 0x87, 0x4E, 0xB1, 0x2C, 0xF0,\
      \ 0x99, 0x6D,\n            0x3A, 0xC4, 0x1F, 0x82, 0x5B, 0xD8, 0x66, 0xE7,\n\
      \            0x24, 0x91, 0x7C, 0x0B, 0x38, 0xF2, 0x4D, 0xC6,\n            0xD3,\
      \ 0x42, 0xA1, 0x7F, 0x9C, 0xE2, 0x55, 0xAA,\n            0x13, 0x87, 0x4E, 0xB1,\
      \ 0x2C, 0xF0, 0x99, 0x6D,\n            0x3A, 0xC4, 0x1F, 0x82, 0x5B, 0xD8, 0x66,\
      \ 0xE7,\n            0x24, 0x91, 0x7C, 0x0B, 0x38, 0xF2, 0x4D, 0xC6,\n     \
      \       0xD3, 0x42, 0xA1, 0x7F, 0x9C, 0xE2, 0x55, 0xAA,\n            0x13, 0x87,\
      \ 0x4E, 0xB1, 0x2C, 0xF0, 0x99, 0x6D,\n            0x3A, 0xC4, 0x1F, 0x82, 0x5B,\
      \ 0xD8, 0x66, 0xE7,\n            0x24, 0x91, 0x7C, 0x0B, 0x38, 0xF2, 0x4D, 0xC6,\n\
      \            0xD3, 0x42, 0xA1, 0x7F, 0x9C, 0xE2, 0x55, 0xAA,\n            0x13,\
      \ 0x87, 0x4E, 0xB1, 0x2C, 0xF0, 0x99, 0x6D,\n            0x3A, 0xC4, 0x1F, 0x82,\
      \ 0x5B, 0xD8, 0x66, 0xE7,\n            0x24, 0x91, 0x7C, 0x0B, 0x38, 0xF2, 0x4D,\
      \ 0xC6\n        ]\n\n        # Message ports\n        self.message_port_register_in(pmt.intern('in'))\n\
      \        self.message_port_register_out(pmt.intern('out'))\n        self.set_msg_handler(pmt.intern('in'),\
      \ self.handle_msg)\n\n    def handle_msg(self, pdu):\n        if not pmt.is_pair(pdu):\n\
      \            return\n\n        meta = pmt.car(pdu)\n        payload = pmt.cdr(pdu)\n\
      \n        if not pmt.is_u8vector(payload):\n            return\n\n        #\
      \ Convert payload to list of ints\n        data = list(pmt.u8vector_elements(payload))\n\
      \n        # Build final PDU: PREAMBLE + DEST + original payload\n        new_data\
      \ = self.preamble + [self.address] + data\n\n        # Convert to PMT\n    \
      \    new_payload = pmt.init_u8vector(len(new_data), new_data)\n\n        # Add\
      \ metadata (optional)\n        meta = pmt.dict_add(meta, pmt.intern(\"dest_addr\"\
      ),\n                            pmt.from_long(self.address))\n\n        # Publish\
      \ final PDU\n        self.message_port_pub(pmt.intern('out'),\n            \
      \                  pmt.cons(meta, new_payload))\n"
    address: '15'
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: "('Add Preamble + Address', 'add_address_block', [('address', '1')],\
      \ [('in', 'message', 1)], [('out', 'message', 1)], '\\n    Adds a fixed 32-byte\
      \ PREAMBLE + 1-byte destination address to each PDU.\\n\\n    Input  PDU format\
      \ :\\n        [ SEQ(1B) | PAYLOAD(32B) | CRC32(4B) ]\\n\\n    Output PDU format\
      \ :\\n        [ PREAMBLE(32B) | DEST(1B) | SEQ(1B) | PAYLOAD(32B) | CRC32(4B)\
      \ ]\\n\\n    Parameters\\n    ----------\\n    address : int (0\u2013255)  Destination\
      \ address\\n    ', ['address'])"
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [520, 328.0]
    rotation: 0
    state: enabled
- name: epy_block_1
  id: epy_block
  parameters:
    _source_code: "\"\"\"\nEmbedded Python Block: WhatsApp-Style Chat (Fixed ACK Logic)\n\
      \"\"\"\n\nimport numpy as np\nfrom gnuradio import gr\nimport pmt\nfrom PyQt5\
      \ import QtWidgets, QtCore, QtGui\nimport sys\nimport datetime\n\n# --- 1. THE\
      \ GUI WINDOW CLASS ---\nclass ChatWindow(QtWidgets.QWidget):\n    rx_signal\
      \ = QtCore.pyqtSignal(str, int)       \n    ack_signal = QtCore.pyqtSignal(int)\
      \           \n\n    def __init__(self, send_callback, dest_name=\"Node A\"):\n\
      \        super(ChatWindow, self).__init__()\n        self.send_callback = send_callback\n\
      \        self.dest_name = dest_name\n        \n        # STATE\n        self.chat_history\
      \ = [] \n        self.last_rx_seq = None\n        self.last_tx_msg = None\n\
      \        self.current_seq_num = 0\n\n        # SIGNALS\n        self.rx_signal.connect(self.handle_rx_gui)\n\
      \        self.ack_signal.connect(self.handle_ack_gui)\n\n        self.setWindowTitle(\"\
      SDR Secure Chat\")\n        self.resize(450, 650)\n        \n        # STYLES\n\
      \        self.setStyleSheet(\"\"\"\n            QWidget { background-color:\
      \ #0b141a; font-family: Helvetica, Arial, sans-serif; font-size: 14px; }\n \
      \           QTextBrowser { border: none; padding: 10px; }\n            QLineEdit\
      \ { background-color: #2a3942; color: #fff; border-radius: 20px; padding: 10px;\
      \ border: 1px solid #2a3942; }\n            QPushButton { background-color:\
      \ #00a884; color: #fff; border-radius: 20px; padding: 10px; font-weight: bold;\
      \ }\n            QLabel { color: #fff; font-size: 16px; padding: 10px; background-color:\
      \ #202c33; }\n        \"\"\")\n\n        # LAYOUT\n        layout = QtWidgets.QVBoxLayout()\n\
      \        layout.setContentsMargins(0, 0, 0, 0)\n        \n        self.header\
      \ = QtWidgets.QLabel(f\"\U0001F464 {self.dest_name}\")\n        self.history\
      \ = QtWidgets.QTextBrowser()\n        \n        input_container = QtWidgets.QWidget()\n\
      \        input_container.setStyleSheet(\"background-color: #202c33;\") \n  \
      \      input_layout = QtWidgets.QHBoxLayout(input_container)\n        \n   \
      \     self.msg_input = QtWidgets.QLineEdit()\n        self.msg_input.setPlaceholderText(\"\
      Type a message\")\n        self.msg_input.returnPressed.connect(self.handle_send_click)\n\
      \n        self.send_btn = QtWidgets.QPushButton(\"\u27A4\")\n        self.send_btn.clicked.connect(self.handle_send_click)\n\
      \n        input_layout.addWidget(self.msg_input)\n        input_layout.addWidget(self.send_btn)\n\
      \n        layout.addWidget(self.header)\n        layout.addWidget(self.history)\n\
      \        layout.addWidget(input_container)\n        self.setLayout(layout)\n\
      \n    # --- SENDER ---\n    def handle_send_click(self):\n        text = self.msg_input.text()\n\
      \        if not text: return\n        \n        self.last_tx_msg = text\n  \
      \      time_str = datetime.datetime.now().strftime(\"%H:%M\")\n        \n  \
      \      seq_to_use = self.current_seq_num\n        \n        self.chat_history.append({\n\
      \            'text': text, 'time': time_str, 'is_own': True, 'acked': False,\
      \ 'seq': seq_to_use\n        })\n        \n        self.refresh_display()\n\
      \        self.msg_input.clear()\n        \n        self.send_callback(text,\
      \ seq_to_use)\n        \n        # Increment (0-255)\n        self.current_seq_num\
      \ = (self.current_seq_num + 1) % 256\n\n    # --- RECEIVER ---\n    def handle_rx_gui(self,\
      \ text, seq):\n        if self.last_tx_msg is not None and text == self.last_tx_msg:\n\
      \            self.last_tx_msg = None\n            return \n\n        if seq\
      \ != -1 and self.last_rx_seq == seq:\n            return \n        if seq !=\
      \ -1: \n            self.last_rx_seq = seq\n\n        time_str = datetime.datetime.now().strftime(\"\
      %H:%M\")\n        \n        self.chat_history.append({\n            'text':\
      \ text, 'time': time_str, 'is_own': False, 'acked': False, 'seq': seq\n    \
      \    })\n        self.refresh_display()\n\n    # --- ACK HANDLER (FIXED) ---\n\
      \    def handle_ack_gui(self, ack_seq):\n        \"\"\"\n        Calculates\
      \ Target Message = (ACK - 1).\n        Because Receiver sends 'Next Expected\
      \ Seq' as ACK.\n        \"\"\"\n        # Calculate the Sequence Number of the\
      \ message that was actually received\n        target_seq = (ack_seq - 1) % 256\n\
      \        \n        updated = False\n        for msg in reversed(self.chat_history):\n\
      \            if msg['is_own'] and msg['seq'] == target_seq:\n              \
      \  if not msg['acked']:\n                    msg['acked'] = True\n         \
      \           updated = True\n                break \n        \n        if updated:\n\
      \            self.refresh_display()\n\n    # --- DISPLAY ---\n    def refresh_display(self):\n\
      \        html = \"\"\n        for msg in self.chat_history:\n            if\
      \ msg['is_own']:\n                tick_color = \"#53bdeb\" if msg['acked'] else\
      \ \"#8696a0\"\n                html += f\"\"\"\n                <table width=\"\
      100%\" border=\"0\" cellpadding=\"2\"><tr><td align=\"right\">\n           \
      \     <div style=\"background-color: #005c4b; color: #e9edef; padding: 8px 12px;\
      \ border-radius: 10px; display: inline-block; text-align: left;\">\n       \
      \         <span style=\"font-size: 14px;\">{msg['text']}</span>\n          \
      \      <div style=\"text-align: right; font-size: 11px; color: #aebac1; margin-top:\
      \ 4px;\">\n                {msg['time']} <span style=\"color: {tick_color};\
      \ font-weight: bold;\">\u2713\u2713</span>\n                </div></div></td></tr></table>\n\
      \                \"\"\"\n            else:\n                html += f\"\"\"\n\
      \                <table width=\"100%\" border=\"0\" cellpadding=\"2\"><tr><td\
      \ align=\"left\">\n                <div style=\"background-color: #202c33; color:\
      \ #e9edef; padding: 8px 12px; border-radius: 10px; display: inline-block; text-align:\
      \ left;\">\n                <span style=\"font-size: 14px;\">{msg['text']}</span>\n\
      \                <div style=\"text-align: right; font-size: 11px; color: #aebac1;\
      \ margin-top: 4px;\">\n                {msg['time']}\n                </div></div></td></tr></table>\n\
      \                \"\"\"\n        self.history.setHtml(html)\n        self.history.moveCursor(QtGui.QTextCursor.End)\n\
      \n\n# --- 2. THE GNU RADIO BLOCK ---\nclass chat_gui_block(gr.basic_block):\n\
      \    def __init__(self, payload_size=32, dest_name=\"Receiver\"):\n        gr.basic_block.__init__(self,\n\
      \            name=\"WhatsApp Chat GUI\",\n            in_sig=None,\n       \
      \     out_sig=None)\n\n        self.payload_size = payload_size\n        \n\
      \        self.message_port_register_out(pmt.intern(\"out\"))\n        self.message_port_register_in(pmt.intern(\"\
      in\"))      \n        self.message_port_register_in(pmt.intern(\"ack_in\"))\
      \  \n\n        self.set_msg_handler(pmt.intern(\"in\"), self.handle_rx_msg)\n\
      \        self.set_msg_handler(pmt.intern(\"ack_in\"), self.handle_ack_msg)\n\
      \n        self.qapp = QtWidgets.QApplication.instance()\n        if not self.qapp:\n\
      \            self.qapp = QtWidgets.QApplication(sys.argv)\n\n        self.gui\
      \ = ChatWindow(self.send_pdus, dest_name=str(dest_name))\n        self.gui.show()\n\
      \n    def send_pdus(self, text, seq_num):\n        data = text.encode(\"utf-8\"\
      , \"ignore\")\n        ps = self.payload_size\n        chunks = [data[i:i+ps]\
      \ for i in range(0, len(data), ps)]\n        if not chunks: chunks = [b'\\x00'*ps]\n\
      \n        for i, chunk in enumerate(chunks):\n            if len(chunk) < ps:\
      \ chunk += b'\\x00' * (ps - len(chunk))\n            meta = pmt.make_dict()\n\
      \            pmt.dict_add(meta, pmt.intern(\"seq\"), pmt.from_long(seq_num))\n\
      \            vec = pmt.init_u8vector(len(chunk), list(chunk))\n            self.message_port_pub(pmt.intern(\"\
      out\"), pmt.cons(meta, vec))\n\n    def handle_rx_msg(self, pdu):\n        if\
      \ not pmt.is_pair(pdu): return\n        meta = pmt.car(pdu)\n        payload\
      \ = pmt.cdr(pdu)\n        if not pmt.is_u8vector(payload): return\n        \n\
      \        seq = -1\n        if pmt.dict_has_key(meta, pmt.intern(\"seq\")):\n\
      \            try:\n                val = pmt.to_python(pmt.dict_ref(meta, pmt.intern(\"\
      seq\"), pmt.PMT_NIL))\n                if isinstance(val, int): seq = val\n\
      \            except: pass\n\n        data = bytes(pmt.u8vector_elements(payload))\n\
      \        try:\n            txt = data.rstrip(b'\\x00').decode('utf-8', 'ignore')\n\
      \            self.gui.rx_signal.emit(txt, seq)\n        except: pass\n\n   \
      \ def handle_ack_msg(self, pdu):\n        if not pmt.is_pair(pdu): return\n\
      \        meta = pmt.car(pdu)\n        payload = pmt.cdr(pdu)\n\n        ack_seq\
      \ = -1\n        \n        if pmt.dict_has_key(meta, pmt.intern(\"ack\")):\n\
      \            try:\n                val = pmt.to_python(pmt.dict_ref(meta, pmt.intern(\"\
      ack\"), pmt.PMT_NIL))\n                if isinstance(val, int): ack_seq = val\n\
      \            except: pass\n        elif pmt.is_u8vector(payload):\n        \
      \    data = bytes(pmt.u8vector_elements(payload))\n            if len(data)\
      \ > 0:\n                ack_seq = int(data[0])\n\n        if ack_seq != -1:\n\
      \            self.gui.ack_signal.emit(ack_seq)\n\n    def stop(self):\n    \
      \    self.gui.close()\n        return super().stop()"
    affinity: ''
    alias: ''
    comment: ''
    dest_name: '1'
    maxoutbuf: '0'
    minoutbuf: '0'
    payload_size: '32'
  states:
    _io_cache: ('WhatsApp Chat GUI', 'chat_gui_block', [('payload_size', '32'), ('dest_name',
      "'Receiver'")], [('ack_in', 'message', 1), ('in', 'message', 1)], [('out', 'message',
      1)], '', ['payload_size'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1376, 476.0]
    rotation: 0
    state: enabled
- name: epy_block_10
  id: epy_block
  parameters:
    _source_code: "from gnuradio import gr\nimport pmt, threading, time\nfrom collections\
      \ import deque\n\nclass payload_to_pdu_with_seq_arq(gr.basic_block):\n    \"\
      \"\"\n    PAYLOAD PDU \u2192 PDU with SEQ + Stop-and-Wait ARQ\n\n    Input PDU\
      \ (port 'in'):\n      Meta: (ignored or optional)\n      Payload: PAYLOAD(payload_size\
      \ bytes) \u2013 will be padded/truncated to fit.\n\n    Output PDU (port 'out'):\n\
      \      Frame = [ SEQ(1 byte) | PAYLOAD(payload_size bytes) ]\n      Meta:\n\
      \        - 'seq': sequence number (0..255)\n\n    ACK rule (same as before):\n\
      \      If TX sent SEQ=s, wait for ACK=(s+1) mod 256 before sending next.\n\n\
      \    Accepted ACKs on 'ack_in':\n      \u2022 Meta dict: {'ack': <int 0..255>}\n\
      \      \u2022 Payload: single byte (first byte used)\n\n    Parameters:\n  \
      \    payload_size : normally 32\n      wait_time_s  : timeout for ACK and retry\
      \ pacing\n      max_retries  : number of retransmissions before giving up\n\
      \      verbose      : print debug log\n    \"\"\"\n\n    def __init__(self,\
      \ payload_size=32, wait_time_s=0.1,\n                 max_retries=10, verbose=True):\n\
      \        gr.basic_block.__init__(self,\n                                name=\"\
      Payload to PDU with SEQ+ARQ\",\n                                in_sig=None,\n\
      \                                out_sig=None)\n\n        self.payload_size\
      \ = int(payload_size)\n        self.wait_time_s  = float(wait_time_s)\n    \
      \    self.max_retries  = int(max_retries)\n        self.verbose      = bool(verbose)\n\
      \n        # Message ports\n        self.message_port_register_in(pmt.intern(\"\
      in\"))       # payload PDUs\n        self.message_port_register_in(pmt.intern(\"\
      ack_in\"))   # ACKs\n        self.message_port_register_out(pmt.intern(\"out\"\
      ))     # final framed PDUs\n\n        self.set_msg_handler(pmt.intern(\"in\"\
      ),     self._handle_payload)\n        self.set_msg_handler(pmt.intern(\"ack_in\"\
      ), self._handle_ack)\n\n        # State\n        self._run       = threading.Event()\n\
      \        self._tx_thread = None\n\n        self._seq       = 0\n        self._last_ack\
      \  = None\n\n        # Queue of pending payloads (bytes objects, length = payload_size)\n\
      \        self._pending_payloads = deque()\n        self._payload_cv = threading.Condition()\n\
      \        self._ack_cv     = threading.Condition()\n\n    # ----- logger -----\n\
      \    def _log(self, msg):\n        if self.verbose:\n            print(f\"[payload_to_pdu_with_seq_arq]\
      \ {msg}\")\n\n    # ----- lifecycle -----\n    def start(self):\n        self._run.set()\n\
      \        self._tx_thread = threading.Thread(target=self._tx_loop, daemon=True)\n\
      \        self._tx_thread.start()\n        self._log(\"TX thread started\")\n\
      \        return super().start()\n\n    def stop(self):\n        self._run.clear()\n\
      \        with self._payload_cv:\n            self._payload_cv.notify_all()\n\
      \        with self._ack_cv:\n            self._ack_cv.notify_all()\n       \
      \ if self._tx_thread:\n            self._tx_thread.join(timeout=1.0)\n     \
      \   self._log(\"TX thread stopped\")\n        return super().stop()\n\n    #\
      \ ----- payload input handler -----\n    def _handle_payload(self, pdu):\n \
      \       \"\"\"\n        Accepts PDUs from the first block.\n        Payload\
      \ is normalized to exactly payload_size bytes\n        (pad with 0x00 or truncate\
      \ if needed).\n        \"\"\"\n        if not pmt.is_pair(pdu):\n          \
      \  return\n\n        meta, pl = pmt.car(pdu), pmt.cdr(pdu)\n\n        if not\
      \ pmt.is_u8vector(pl):\n            return\n\n        data = bytes(pmt.u8vector_elements(pl))\n\
      \n        # Normalize to fixed payload_size\n        if len(data) < self.payload_size:\n\
      \            data = data + b\"\\x00\" * (self.payload_size - len(data))\n  \
      \      elif len(data) > self.payload_size:\n            data = data[:self.payload_size]\n\
      \n        with self._payload_cv:\n            self._pending_payloads.append(data)\n\
      \            self._payload_cv.notify()\n\n        self._log(f\"Queued payload\
      \ (len={len(data)} bytes), queue size={len(self._pending_payloads)}\")\n\n \
      \   # ----- ACK handler (same logic as original) -----\n    def _handle_ack(self,\
      \ pdu):\n        ack_val = None\n        if pmt.is_pair(pdu):\n            meta,\
      \ pl = pmt.car(pdu), pmt.cdr(pdu)\n            # meta-based ACK\n          \
      \  if pmt.is_dict(meta):\n                k = pmt.intern(\"ack\")\n        \
      \        if pmt.dict_has_key(meta, k):\n                    try:\n         \
      \               v = pmt.to_python(pmt.dict_ref(meta, k, pmt.PMT_NIL))\n    \
      \                    if isinstance(v, int):\n                            ack_val\
      \ = v & 0xFF\n                    except Exception:\n                      \
      \  pass\n            # payload-based ACK (first byte)\n            if ack_val\
      \ is None and pmt.is_u8vector(pl):\n                data = bytes(pmt.u8vector_elements(pl))\n\
      \                if len(data) >= 1:\n                    ack_val = data[0] &\
      \ 0xFF\n\n        if ack_val is not None:\n            with self._ack_cv:\n\
      \                self._last_ack = ack_val\n                self._ack_cv.notify_all()\n\
      \            self._log(f\"Received ACK={ack_val}\")\n\n    # ----- TX loop with\
      \ Stop-and-Wait ARQ -----\n    def _tx_loop(self):\n        while self._run.is_set():\n\
      \            # 1) Get next payload from queue\n            with self._payload_cv:\n\
      \                while self._run.is_set() and not self._pending_payloads:\n\
      \                    self._payload_cv.wait(timeout=0.1)\n\n                if\
      \ not self._run.is_set():\n                    break\n\n                payload\
      \ = self._pending_payloads.popleft()\n\n            seq = self._seq\n      \
      \      expected_ack = (seq + 1) & 0xFF\n            frame = bytes([seq]) + payload\n\
      \n            retries = 0\n            got_ack = False\n            self._log(f\"\
      TX seq={seq}, expecting ACK={expected_ack}\")\n\n            # 2) Stop-and-Wait\
      \ ARQ logic for this payload\n            while self._run.is_set() and not got_ack:\n\
      \                # Send packet\n                self._publish(frame)\n\n   \
      \             # Wait for ACK\n                deadline = time.monotonic() +\
      \ self.wait_time_s\n                while self._run.is_set() and time.monotonic()\
      \ < deadline:\n                    with self._ack_cv:\n                    \
      \    remaining = max(0.0, deadline - time.monotonic())\n                   \
      \     self._ack_cv.wait(timeout=remaining)\n                        if self._last_ack\
      \ == expected_ack:\n                            got_ack = True\n           \
      \                 self._log(f\"ACK={expected_ack} OK for seq={seq}\")\n    \
      \                        break\n\n                if not got_ack:\n        \
      \            retries += 1\n                    if retries <= self.max_retries:\n\
      \                        self._log(f\"Timeout waiting for ACK={expected_ack}\
      \ (seq={seq}), retry {retries}/{self.max_retries}\")\n                    if\
      \ retries > self.max_retries:\n                        self._log(f\"[ARQ] No\
      \ ACK for seq={seq}, giving up after {self.max_retries} retries\")\n       \
      \                 got_ack = True  # give up and proceed\n\n            # 3)\
      \ Advance sequence number after we're done with this payload\n            self._seq\
      \ = expected_ack\n\n        self._log(\"TX loop exiting\")\n\n    # ----- Publish\
      \ final framed PDU -----\n    def _publish(self, frame: bytes):\n        meta\
      \ = pmt.make_dict()\n        meta = pmt.dict_add(meta, pmt.intern(\"seq\"),\
      \ pmt.from_long(frame[0]))\n        payload_list = list(frame)\n        payload_pmt\
      \ = pmt.init_u8vector(len(payload_list), payload_list)\n        self.message_port_pub(pmt.intern(\"\
      out\"), pmt.cons(meta, payload_pmt))\n"
    affinity: ''
    alias: ''
    comment: ''
    max_retries: '10'
    maxoutbuf: '0'
    minoutbuf: '0'
    payload_size: '40'
    verbose: 'True'
    wait_time_s: '1'
  states:
    _io_cache: "('Payload to PDU with SEQ+ARQ', 'payload_to_pdu_with_seq_arq', [('payload_size',\
      \ '32'), ('wait_time_s', '0.1'), ('max_retries', '10'), ('verbose', 'True')],\
      \ [('ack_in', 'message', 1), ('in', 'message', 1)], [('out', 'message', 1)],\
      \ \"\\n    PAYLOAD PDU \u2192 PDU with SEQ + Stop-and-Wait ARQ\\n\\n    Input\
      \ PDU (port 'in'):\\n      Meta: (ignored or optional)\\n      Payload: PAYLOAD(payload_size\
      \ bytes) \u2013 will be padded/truncated to fit.\\n\\n    Output PDU (port 'out'):\\\
      n      Frame = [ SEQ(1 byte) | PAYLOAD(payload_size bytes) ]\\n      Meta:\\\
      n        - 'seq': sequence number (0..255)\\n\\n    ACK rule (same as before):\\\
      n      If TX sent SEQ=s, wait for ACK=(s+1) mod 256 before sending next.\\n\\\
      n    Accepted ACKs on 'ack_in':\\n      \u2022 Meta dict: {'ack': <int 0..255>}\\\
      n      \u2022 Payload: single byte (first byte used)\\n\\n    Parameters:\\\
      n      payload_size : normally 32\\n      wait_time_s  : timeout for ACK and\
      \ retry pacing\\n      max_retries  : number of retransmissions before giving\
      \ up\\n      verbose      : print debug log\\n    \", ['max_retries', 'payload_size',\
      \ 'verbose', 'wait_time_s'])"
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [280, 216.0]
    rotation: 0
    state: enabled
- name: epy_block_11
  id: epy_block
  parameters:
    _source_code: "from gnuradio import gr\nimport pmt, zlib\n\nclass crc32_verify_and_ack(gr.basic_block):\n\
      \    \"\"\"\n    CRC32 Verify & ACK\n    ----------------------------------------------------------------\n\
      \    Input  PDU : [ SEQ(1B) | PAYLOAD(40B) | CRC32(4B, big-endian) ]\n    PAYLOAD\
      \   : [ NONCE(8B) | CIPHERTEXT(32B) ]\n    CRC over  : [ SEQ | PAYLOAD ]  ->\
      \ total 41 bytes\n\n    On CRC pass:\n      - 'out'     \u2192 PAYLOAD only\
      \ (40 bytes),\n                    meta: {crc_ok=True, seq=<seq>, ...}\n   \
      \   - 'ack_out' \u2192 payload: [ NEXT_SEQ(1B) | PAYLOAD(40B) ]  (41 bytes)\n\
      \                    meta:   {ack=<next_seq>, crc_ok=True}\n\n    On CRC fail:\n\
      \      - 'drop'    \u2192 diagnostic PDU with {crc_ok=False, drop_reason=...}\n\
      \n    Parameters\n      variant : \"ieee\"  (init/xor=0xFFFFFFFF, reflected)\n\
      \                \"zlib\"  (init/xor=0x00000000, reflected)\n    \"\"\"\n\n\
      \    def __init__(self, variant=\"ieee\"):\n        gr.basic_block.__init__(self,\
      \ name=\"CRC32 Verifier\",\n                                in_sig=None, out_sig=None)\n\
      \        self.variant = str(variant).lower().strip()\n        if self.variant\
      \ not in (\"ieee\", \"zlib\"):\n            self.variant = \"ieee\"\n\n    \
      \    # Fixed payload length: 40 bytes (8B nonce + 32B ciphertext)\n        self.payload_len\
      \ = 40\n\n        # Ports\n        self.message_port_register_in(pmt.intern('in'))\n\
      \        self.set_msg_handler(pmt.intern('in'), self._handle)\n        self.message_port_register_out(pmt.intern('out'))\
      \      # 40B payload only\n        self.message_port_register_out(pmt.intern('ack_out'))\
      \  # NEXT_SEQ + PAYLOAD\n        self.message_port_register_out(pmt.intern('drop'))\
      \     # diagnostics\n\n    # CRC engines\n    def _crc32(self, data: bytes)\
      \ -> int:\n        if self.variant == \"ieee\":\n            # CRC-32/IEEE 802.3:\
      \ reflected, init=0xFFFFFFFF, xorout=0xFFFFFFFF\n            return (zlib.crc32(data,\
      \ 0xFFFFFFFF) ^ 0xFFFFFFFF) & 0xFFFFFFFF\n        else:\n            # zlib\
      \ default: reflected, init=0x00000000, xorout=0x00000000\n            return\
      \ zlib.crc32(data) & 0xFFFFFFFF\n\n    def _handle(self, pdu):\n        if not\
      \ pmt.is_pair(pdu):\n            return\n        meta, pl = pmt.car(pdu), pmt.cdr(pdu)\n\
      \        if not pmt.is_u8vector(pl):\n            return\n\n        buf = bytes(pmt.u8vector_elements(pl))\n\
      \n        # Expect exactly SEQ(1) + PAYLOAD(40) + CRC(4) = 45 bytes\n      \
      \  expected_len = 1 + self.payload_len + 4\n        if len(buf) < expected_len:\n\
      \            self._emit_drop(meta, buf, \"short_frame\")\n            return\n\
      \n        body   = buf[:-4]  # [SEQ | PAYLOAD]\n        crc_rx = int.from_bytes(buf[-4:],\
      \ byteorder='big')\n\n        # Expect exactly 1 + payload_len bytes in body\n\
      \        if len(body) != 1 + self.payload_len:\n            self._emit_drop(meta,\
      \ buf, \"bad_payload_len\")\n            return\n\n        seq     = body[0]\n\
      \        payload = body[1:]  # 40 bytes: [NONCE(8) | CIPHERTEXT(32)]\n\n   \
      \     if self._crc32(body) != crc_rx:\n            self._emit_drop(meta, buf,\
      \ \"crc_fail\")\n            return\n\n        # ---- Publish PAYLOAD only on\
      \ 'out' (40B) ----\n        out_meta = meta\n        try:\n            out_meta\
      \ = pmt.dict_add(out_meta, pmt.intern(\"crc_ok\"), pmt.from_bool(True))\n  \
      \          out_meta = pmt.dict_add(out_meta, pmt.intern(\"seq\"),    pmt.from_long(int(seq)))\n\
      \        except Exception:\n            pass\n\n        self.message_port_pub(\n\
      \            pmt.intern('out'),\n            pmt.cons(out_meta, pmt.init_u8vector(len(payload),\
      \ list(payload)))\n        )\n\n        # ---- Publish ACK: [ NEXT_SEQ | PAYLOAD(40B)\
      \ ] ----\n        ack_next = (seq + 1) & 0xFF\n        ack_meta = pmt.make_dict()\n\
      \        try:\n            ack_meta = pmt.dict_add(ack_meta, pmt.intern(\"ack\"\
      ),    pmt.from_long(ack_next))\n            ack_meta = pmt.dict_add(ack_meta,\
      \ pmt.intern(\"crc_ok\"), pmt.from_bool(True))\n        except Exception:\n\
      \            pass\n\n        ack_bytes = [ack_next] + list(payload)  # 1 + 40\
      \ = 41 bytes\n        self.message_port_pub(\n            pmt.intern('ack_out'),\n\
      \            pmt.cons(ack_meta, pmt.init_u8vector(len(ack_bytes), ack_bytes))\n\
      \        )\n\n    def _emit_drop(self, meta, data_bytes, reason):\n        try:\n\
      \            m = meta\n            if not pmt.is_dict(m):\n                m\
      \ = pmt.make_dict()\n            m = pmt.dict_add(m, pmt.intern(\"crc_ok\"),\
      \      pmt.from_bool(False))\n            m = pmt.dict_add(m, pmt.intern(\"\
      drop_reason\"), pmt.intern(str(reason)))\n            v = pmt.init_u8vector(len(data_bytes),\
      \ list(data_bytes))\n            self.message_port_pub(pmt.intern('drop'), pmt.cons(m,\
      \ v))\n        except Exception:\n            pass\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    variant: '"zlib"'
  states:
    _io_cache: "('CRC32 Verifier', 'crc32_verify_and_ack', [('variant', \"'ieee'\"\
      )], [('in', 'message', 1)], [('drop', 'message', 1), ('ack_out', 'message',\
      \ 1), ('out', 'message', 1)], '\\n    CRC32 Verify & ACK\\n    ----------------------------------------------------------------\\\
      n    Input  PDU : [ SEQ(1B) | PAYLOAD(40B) | CRC32(4B, big-endian) ]\\n    PAYLOAD\
      \   : [ NONCE(8B) | CIPHERTEXT(32B) ]\\n    CRC over  : [ SEQ | PAYLOAD ]  ->\
      \ total 41 bytes\\n\\n    On CRC pass:\\n      - \\'out\\'     \u2192 PAYLOAD\
      \ only (40 bytes),\\n                    meta: {crc_ok=True, seq=<seq>, ...}\\\
      n      - \\'ack_out\\' \u2192 payload: [ NEXT_SEQ(1B) | PAYLOAD(40B) ]  (41\
      \ bytes)\\n                    meta:   {ack=<next_seq>, crc_ok=True}\\n\\n \
      \   On CRC fail:\\n      - \\'drop\\'    \u2192 diagnostic PDU with {crc_ok=False,\
      \ drop_reason=...}\\n\\n    Parameters\\n      variant : \"ieee\"  (init/xor=0xFFFFFFFF,\
      \ reflected)\\n                \"zlib\"  (init/xor=0x00000000, reflected)\\\
      n    ', ['variant'])"
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [888, 1248.0]
    rotation: 0
    state: enabled
- name: epy_block_12
  id: epy_block
  parameters:
    _source_code: "from gnuradio import gr\nimport pmt, zlib\n\nclass ack_crc32_verify_minimal(gr.basic_block):\n\
      \    \"\"\"\n    ACK CRC32 Verify (Minimal, 1-byte ACK)\n    -------------------------------------\n\
      \    Input PDU (port 'in'):\n        Payload: [ NEXT_SEQ(1B) | PAYLOAD(40B)\
      \ | CRC32(4B, big-endian) ]\n        CRC over: [ NEXT_SEQ | PAYLOAD ]  (1 +\
      \ 40 = 41 bytes)\n\n    On CRC pass:\n        \u2192 'ack_out': PDU with\n \
      \            meta:    { ack: NEXT_SEQ, crc_ok: True }\n             payload:\
      \ [ NEXT_SEQ ]  (1 byte)\n\n    On CRC fail:\n        \u2192 'drop': PDU with\
      \ original frame and meta:\n             { crc_ok: False, drop_reason: \"crc_fail\"\
      \ or \"bad_len\" }\n\n    Parameters\n      variant : \"ieee\"  (init/xor=0xFFFFFFFF,\
      \ reflected)\n                \"zlib\"  (init/xor=0x00000000, reflected)\n \
      \   \"\"\"\n\n    def __init__(self, variant=\"ieee\"):\n        gr.basic_block.__init__(self,\n\
      \                                name=\"CRC32 Verifier ACK\",\n            \
      \                    in_sig=None,\n                                out_sig=None)\n\
      \n        self.variant = str(variant).lower().strip()\n        if self.variant\
      \ not in (\"ieee\", \"zlib\"):\n            self.variant = \"ieee\"\n\n    \
      \    # Expected payload layout: 1 (next_seq) + 40 (payload) + 4 (crc32)\n  \
      \      self.payload_len = 40\n\n        # Ports\n        self.message_port_register_in(pmt.intern(\"\
      in\"))\n        self.set_msg_handler(pmt.intern(\"in\"), self._handle)\n\n \
      \       self.message_port_register_out(pmt.intern(\"ack_out\"))\n        self.message_port_register_out(pmt.intern(\"\
      drop\"))\n\n    # --- CRC helper ---\n    def _crc32(self, data: bytes) -> int:\n\
      \        if self.variant == \"ieee\":\n            # CRC-32/IEEE 802.3: reflected,\
      \ init=0xFFFFFFFF, xorout=0xFFFFFFFF\n            return (zlib.crc32(data, 0xFFFFFFFF)\
      \ ^ 0xFFFFFFFF) & 0xFFFFFFFF\n        else:\n            # zlib default: reflected,\
      \ init=0x00000000, xorout=0x00000000\n            return zlib.crc32(data) &\
      \ 0xFFFFFFFF\n\n    # --- main handler ---\n    def _handle(self, pdu):\n  \
      \      if not pmt.is_pair(pdu):\n            return\n\n        meta, pl = pmt.car(pdu),\
      \ pmt.cdr(pdu)\n        if not pmt.is_u8vector(pl):\n            return\n\n\
      \        buf = bytes(pmt.u8vector_elements(pl))\n\n        # Expect exactly\
      \ NEXT_SEQ(1) + PAYLOAD(40) + CRC32(4) = 45 bytes\n        expected_len = 1\
      \ + self.payload_len + 4\n        if len(buf) != expected_len:\n           \
      \ self._emit_drop(meta, buf, \"bad_len\")\n            return\n\n        body\
      \   = buf[:-4]                         # [ NEXT_SEQ | PAYLOAD(40B) ]\n     \
      \   crc_rx = int.from_bytes(buf[-4:], \"big\")\n        next_seq = body[0]\n\
      \n        if self._crc32(body) != crc_rx:\n            self._emit_drop(meta,\
      \ buf, \"crc_fail\")\n            return\n\n        # --- Publish 1-byte ACK\
      \ PDU ---\n        ack_meta = pmt.make_dict()\n        try:\n            ack_meta\
      \ = pmt.dict_add(ack_meta, pmt.intern(\"ack\"),\n                          \
      \          pmt.from_long(int(next_seq)))\n            ack_meta = pmt.dict_add(ack_meta,\
      \ pmt.intern(\"crc_ok\"),\n                                    pmt.from_bool(True))\n\
      \        except Exception:\n            pass\n\n        ack_payload = [int(next_seq)\
      \ & 0xFF]\n        self.message_port_pub(\n            pmt.intern(\"ack_out\"\
      ),\n            pmt.cons(ack_meta, pmt.init_u8vector(1, ack_payload))\n    \
      \    )\n\n    def _emit_drop(self, meta, data_bytes, reason):\n        try:\n\
      \            m = meta\n            if not pmt.is_dict(m):\n                m\
      \ = pmt.make_dict()\n            m = pmt.dict_add(m, pmt.intern(\"crc_ok\"),\
      \ pmt.from_bool(False))\n            m = pmt.dict_add(m, pmt.intern(\"drop_reason\"\
      ),\n                             pmt.intern(str(reason)))\n            v = pmt.init_u8vector(len(data_bytes),\
      \ list(data_bytes))\n            self.message_port_pub(pmt.intern(\"drop\"),\
      \ pmt.cons(m, v))\n        except Exception:\n            pass\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    variant: '"zlib"'
  states:
    _io_cache: "('CRC32 Verifier ACK', 'ack_crc32_verify_minimal', [('variant', \"\
      'ieee'\")], [('in', 'message', 1)], [('drop', 'message', 1), ('ack_out', 'message',\
      \ 1)], '\\n    ACK CRC32 Verify (Minimal, 1-byte ACK)\\n    -------------------------------------\\\
      n    Input PDU (port \\'in\\'):\\n        Payload: [ NEXT_SEQ(1B) | PAYLOAD(40B)\
      \ | CRC32(4B, big-endian) ]\\n        CRC over: [ NEXT_SEQ | PAYLOAD ]  (1 +\
      \ 40 = 41 bytes)\\n\\n    On CRC pass:\\n        \u2192 \\'ack_out\\': PDU with\\\
      n             meta:    { ack: NEXT_SEQ, crc_ok: True }\\n             payload:\
      \ [ NEXT_SEQ ]  (1 byte)\\n\\n    On CRC fail:\\n        \u2192 \\'drop\\':\
      \ PDU with original frame and meta:\\n             { crc_ok: False, drop_reason:\
      \ \"crc_fail\" or \"bad_len\" }\\n\\n    Parameters\\n      variant : \"ieee\"\
      \  (init/xor=0xFFFFFFFF, reflected)\\n                \"zlib\"  (init/xor=0x00000000,\
      \ reflected)\\n    ', ['variant'])"
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1056, 2240.0]
    rotation: 0
    state: enabled
- name: epy_block_1_0
  id: epy_block
  parameters:
    _source_code: "from gnuradio import gr\nimport pmt\n\nclass add_ack_address_block(gr.basic_block):\n\
      \    \"\"\"\n    Add 32-byte PREAMBLE + DEST Address to ACK Frames\n    --------------------------------------------------\n\
      \    Output structure:\n      [ PREAMBLE(32 bytes) | DEST(1 byte) | ACK_PAYLOAD(...)\
      \ ]\n\n    Parameters:\n      dest_addr : destination address for ACK (0\u2013\
      255)\n    \"\"\"\n\n    def __init__(self, dest_addr=20):\n        gr.basic_block.__init__(\n\
      \            self,\n            name=\"Add ACK Preamble + Address\",\n     \
      \       in_sig=None,\n            out_sig=None)\n\n        # 1-byte destination\
      \ address\n        self.dest_addr = int(dest_addr) & 0xFF\n\n        # ----\
      \ SAME 32-BYTE PREAMBLE AS TRANSMITTER ----\n        self.preamble = [\n   \
      \         0xD3, 0x42, 0xA1, 0x7F, 0x9C, 0xE2, 0x55, 0xAA,\n            0x13,\
      \ 0x87, 0x4E, 0xB1, 0x2C, 0xF0, 0x99, 0x6D,\n            0x3A, 0xC4, 0x1F, 0x82,\
      \ 0x5B, 0xD8, 0x66, 0xE7,\n            0x24, 0x91, 0x7C, 0x0B, 0x38, 0xF2, 0x4D,\
      \ 0xC6,\n            0xD3, 0x42, 0xA1, 0x7F, 0x9C, 0xE2, 0x55, 0xAA,\n     \
      \       0x13, 0x87, 0x4E, 0xB1, 0x2C, 0xF0, 0x99, 0x6D,\n            0x3A, 0xC4,\
      \ 0x1F, 0x82, 0x5B, 0xD8, 0x66, 0xE7,\n            0x24, 0x91, 0x7C, 0x0B, 0x38,\
      \ 0xF2, 0x4D, 0xC6,\n            0xD3, 0x42, 0xA1, 0x7F, 0x9C, 0xE2, 0x55, 0xAA,\n\
      \            0x13, 0x87, 0x4E, 0xB1, 0x2C, 0xF0, 0x99, 0x6D,\n            0x3A,\
      \ 0xC4, 0x1F, 0x82, 0x5B, 0xD8, 0x66, 0xE7,\n            0x24, 0x91, 0x7C, 0x0B,\
      \ 0x38, 0xF2, 0x4D, 0xC6,\n            0xD3, 0x42, 0xA1, 0x7F, 0x9C, 0xE2, 0x55,\
      \ 0xAA,\n            0x13, 0x87, 0x4E, 0xB1, 0x2C, 0xF0, 0x99, 0x6D,\n     \
      \       0x3A, 0xC4, 0x1F, 0x82, 0x5B, 0xD8, 0x66, 0xE7,\n            0x24, 0x91,\
      \ 0x7C, 0x0B, 0x38, 0xF2, 0x4D, 0xC6\n        ]\n\n        # Register ports\n\
      \        self.message_port_register_in(pmt.intern('in'))\n        self.message_port_register_out(pmt.intern('out'))\n\
      \        self.set_msg_handler(pmt.intern('in'), self.handle_msg)\n\n    def\
      \ handle_msg(self, pdu):\n        if not pmt.is_pair(pdu):\n            return\n\
      \n        meta = pmt.car(pdu)\n        payload = pmt.cdr(pdu)\n\n        if\
      \ not pmt.is_u8vector(payload):\n            return\n\n        # Convert payload\
      \ to a list of ints\n        data = list(pmt.u8vector_elements(payload))\n\n\
      \        # Build final ACK frame:\n        # [ PREAMBLE | DEST | ORIGINAL_ACK_DATA\
      \ ]\n        new_frame = self.preamble + [self.dest_addr] + data\n\n       \
      \ # Add metadata (optional)\n        new_meta = meta\n        try:\n       \
      \     new_meta = pmt.dict_add(new_meta, pmt.intern(\"dest_addr\"),\n       \
      \                             pmt.from_long(self.dest_addr))\n        except\
      \ Exception:\n            pass\n\n        # Convert back to PMT\n        new_payload_pmt\
      \ = pmt.init_u8vector(len(new_frame), new_frame)\n\n        # Publish new ACK\
      \ PDU\n        self.message_port_pub(pmt.intern('out'),\n                  \
      \            pmt.cons(new_meta, new_payload_pmt))\n"
    affinity: ''
    alias: ''
    comment: ''
    dest_addr: '12'
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: "('Add ACK Preamble + Address', 'add_ack_address_block', [('dest_addr',\
      \ '20')], [('in', 'message', 1)], [('out', 'message', 1)], '\\n    Add 32-byte\
      \ PREAMBLE + DEST Address to ACK Frames\\n    --------------------------------------------------\\\
      n    Output structure:\\n      [ PREAMBLE(32 bytes) | DEST(1 byte) | ACK_PAYLOAD(...)\
      \ ]\\n\\n    Parameters:\\n      dest_addr : destination address for ACK (0\u2013\
      255)\\n    ', ['dest_addr'])"
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1304, 1168.0]
    rotation: 0
    state: enabled
- name: epy_block_2
  id: epy_block
  parameters:
    _source_code: "from gnuradio import gr\nimport pmt\n\nclass address_filter_rx(gr.basic_block):\n\
      \    \"\"\"\n    Address Filter (RX) with preamble stripping\n\n    Expects\
      \ PDU payload:\n      [ PREAMBLE(NB) | DEST(1B) | SEQ(1B) | PAYLOAD(...) | CRC32(4B)\
      \ ]\n\n    Behavior:\n      - Strips PREAMBLE and DEST\n      - Forwards [ SEQ\
      \ | PAYLOAD | CRC32 ]\n      - Only forwards if DEST == my_addr\n      - Adds\
      \ 'dest_addr', 'seq', and 'packet_len' metadata\n      - Publishes dropped frames\
      \ on 'drop' port with reason\n    \"\"\"\n\n    def __init__(self, my_addr=15,\
      \ preamble_len=32):\n        gr.basic_block.__init__(self, name=\"Address Filter\"\
      , in_sig=None, out_sig=None)\n        self.my_addr = int(my_addr) & 0xFF\n \
      \       self.preamble_len = int(preamble_len)\n\n        # Message ports\n \
      \       self.message_port_register_in(pmt.intern('in'))\n        self.set_msg_handler(pmt.intern('in'),\
      \ self._handle)\n        self.message_port_register_out(pmt.intern('out'))\n\
      \        self.message_port_register_out(pmt.intern('drop'))\n\n    def _handle(self,\
      \ pdu):\n        if not pmt.is_pair(pdu):\n            return\n\n        meta\
      \ = pmt.car(pdu)\n        pl = pmt.cdr(pdu)\n\n        if not pmt.is_u8vector(pl):\n\
      \            return\n\n        data = bytes(pmt.u8vector_elements(pl))\n\n \
      \       # Need at least: PREAMBLE + DEST + SEQ + CRC32 (payload can be 0+)\n\
      \        min_len = self.preamble_len + 1 + 1 + 4\n        if len(data) < min_len:\n\
      \            self._emit_drop(meta, data, reason=\"short_frame\")\n         \
      \   return\n\n        # Strip preamble first\n        frame = data[self.preamble_len:]\
      \      # [ DEST | SEQ | PAYLOAD | CRC32 ]\n        dest = frame[0]\n\n     \
      \   if dest != self.my_addr:\n            self._emit_drop(meta, data, reason=\"\
      addr_mismatch\")\n            return\n\n        # Strip DEST: output [ SEQ |\
      \ PAYLOAD | CRC32 ]\n        fwd = frame[1:]\n        if len(fwd) < 1 + 4: \
      \ # SEQ + CRC32 at minimum\n            self._emit_drop(meta, data, reason=\"\
      short_after_strip\")\n            return\n\n        seq = fwd[0]\n\n       \
      \ # Add useful metadata\n        out_meta = meta\n        try:\n           \
      \ out_meta = pmt.dict_add(out_meta, pmt.intern(\"dest_addr\"), pmt.from_long(dest))\n\
      \            out_meta = pmt.dict_add(out_meta, pmt.intern(\"seq\"), pmt.from_long(seq))\n\
      \            out_meta = pmt.dict_add(out_meta, pmt.intern(\"packet_len\"), pmt.from_long(len(fwd)))\n\
      \        except Exception:\n            pass\n\n        # Publish stripped frame\n\
      \        out_vec = pmt.init_u8vector(len(fwd), list(fwd))\n        self.message_port_pub(pmt.intern('out'),\
      \ pmt.cons(out_meta, out_vec))\n\n    def _emit_drop(self, meta, data_bytes,\
      \ reason=\"drop\"):\n        try:\n            # Try to extract DEST as seen\
      \ on the air (after preamble, if present)\n            if len(data_bytes) >\
      \ self.preamble_len:\n                dest_seen = data_bytes[self.preamble_len]\n\
      \            else:\n                dest_seen = -1\n\n            m = pmt.dict_add(meta,\
      \ pmt.intern(\"drop_reason\"), pmt.intern(reason))\n            m = pmt.dict_add(m,\
      \ pmt.intern(\"dest_seen\"), pmt.from_long(dest_seen))\n            v = pmt.init_u8vector(len(data_bytes),\
      \ list(data_bytes))\n            self.message_port_pub(pmt.intern('drop'), pmt.cons(m,\
      \ v))\n        except Exception:\n            pass\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    my_addr: '15'
    preamble_len: '128'
  states:
    _io_cache: ('Address Filter', 'address_filter_rx', [('my_addr', '15'), ('preamble_len',
      '32')], [('in', 'message', 1)], [('drop', 'message', 1), ('out', 'message',
      1)], "\n    Address Filter (RX) with preamble stripping\n\n    Expects PDU payload:\n      [
      PREAMBLE(NB) | DEST(1B) | SEQ(1B) | PAYLOAD(...) | CRC32(4B) ]\n\n    Behavior:\n      -
      Strips PREAMBLE and DEST\n      - Forwards [ SEQ | PAYLOAD | CRC32 ]\n      -
      Only forwards if DEST == my_addr\n      - Adds 'dest_addr', 'seq', and 'packet_len'
      metadata\n      - Publishes dropped frames on 'drop' port with reason\n    ",
      ['my_addr', 'preamble_len'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [656, 1248.0]
    rotation: 0
    state: enabled
- name: epy_block_4
  id: epy_block
  parameters:
    _source_code: "from gnuradio import gr\nimport pmt\nfrom Crypto.Cipher import\
      \ AES\nimport os\n\nclass pdu_aes_encrypt(gr.basic_block):\n    \"\"\"\n   \
      \ PDU AES Encrypt (AES-CTR)\n\n    In:\n      - PDU: (meta, payload_bytes)\n\
      \n    Out:\n      - PDU: same meta\n              payload = NONCE(8 bytes) |\
      \ CIPHERTEXT(len(payload_bytes))\n\n    Parameters:\n      key_hex : AES key\
      \ in hex (16/24/32 bytes => 32/48/64 hex chars)\n      verbose : print debug\n\
      \    \"\"\"\n\n    def __init__(self, key_hex=\"00112233445566778899AABBCCDDEEFF\"\
      , verbose=True):\n        gr.basic_block.__init__(self,\n                  \
      \              name=\"PDU AES Encrypt (CTR)\",\n                           \
      \     in_sig=None,\n                                out_sig=None)\n\n      \
      \  self.verbose = bool(verbose)\n        self.set_key_hex(key_hex)\n\n     \
      \   self.message_port_register_in(pmt.intern(\"in\"))\n        self.message_port_register_out(pmt.intern(\"\
      out\"))\n        self.set_msg_handler(pmt.intern(\"in\"), self._handle_msg)\n\
      \n    def _log(self, msg):\n        if self.verbose:\n            print(f\"\
      [pdu_aes_encrypt] {msg}\")\n\n    # ---- key handling ----\n    def set_key_hex(self,\
      \ key_hex):\n        \"\"\"\n        Set AES key as hex string (32/48/64 hex\
      \ chars).\n        Can be used as a GRC callback.\n        \"\"\"\n        key_hex\
      \ = key_hex.replace(\" \", \"\")\n        try:\n            key = bytes.fromhex(key_hex)\n\
      \        except ValueError:\n            raise ValueError(\"key_hex must be\
      \ valid hex\")\n\n        if len(key) not in (16, 24, 32):\n            raise\
      \ ValueError(\"AES key must be 16, 24, or 32 bytes (32/48/64 hex chars)\")\n\
      \n        self._key = key\n        self._log(f\"Key set ({len(key)} bytes)\"\
      )\n\n    # ---- message handler ----\n    def _handle_msg(self, pdu):\n    \
      \    if not pmt.is_pair(pdu):\n            return\n\n        meta = pmt.car(pdu)\n\
      \        pl   = pmt.cdr(pdu)\n\n        if not pmt.is_u8vector(pl):\n      \
      \      self._log(\"Ignoring non-u8vector payload\")\n            return\n\n\
      \        plaintext = bytes(pmt.u8vector_elements(pl))\n\n        # Generate\
      \ random nonce (8 bytes) for AES-CTR\n        nonce = os.urandom(8)\n\n    \
      \    cipher = AES.new(self._key, AES.MODE_CTR, nonce=nonce)\n        ciphertext\
      \ = cipher.encrypt(plaintext)\n\n        out_bytes = nonce + ciphertext\n\n\
      \        payload_pmt = pmt.init_u8vector(len(out_bytes), list(out_bytes))\n\
      \        out_pdu = pmt.cons(meta, payload_pmt)\n        self.message_port_pub(pmt.intern(\"\
      out\"), out_pdu)\n\n        self._log(f\"Encrypted PDU: in_len={len(plaintext)},\
      \ out_len={len(out_bytes)}\")\n"
    affinity: ''
    alias: ''
    comment: ''
    key_hex: aes_key
    maxoutbuf: '0'
    minoutbuf: '0'
    verbose: 'False'
  states:
    _io_cache: '(''PDU AES Encrypt (CTR)'', ''pdu_aes_encrypt'', [(''key_hex'', "''00112233445566778899AABBCCDDEEFF''"),
      (''verbose'', ''True'')], [(''in'', ''message'', 1)], [(''out'', ''message'',
      1)], ''\n    PDU AES Encrypt (AES-CTR)\n\n    In:\n      - PDU: (meta, payload_bytes)\n\n    Out:\n      -
      PDU: same meta\n              payload = NONCE(8 bytes) | CIPHERTEXT(len(payload_bytes))\n\n    Parameters:\n      key_hex
      : AES key in hex (16/24/32 bytes => 32/48/64 hex chars)\n      verbose : print
      debug\n    '', [''verbose''])'
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [200, 400.0]
    rotation: 0
    state: enabled
- name: epy_block_5
  id: epy_block
  parameters:
    _source_code: "from gnuradio import gr\nimport pmt, os, threading\n\nclass pdu_payload_to_file(gr.basic_block):\n\
      \    \"\"\"\n    PDU Payload \u2192 File\n    ------------------\n    Input\
      \  PDUs (from crc32_verify_and_ack.out): [ PAYLOAD(32B) ] with meta {seq, packet_len=32,\
      \ crc_ok=True}\n    Action: Appends PAYLOAD to a file, once per new sequence\
      \ number.\n            On stop (or CTRL \"FLUSH\"), optionally trims trailing\
      \ 0x00 bytes (padding).\n\n    Parameters\n    ----------\n    output_path :\
      \ str   Path to output file (use r\\\"D:\\\\path\\\\out.txt\\\" on Windows)\n\
      \    overwrite   : int   1 = truncate on start, 0 = append if file exists  (default\
      \ 1)\n    strip_zeros_on_close : int  1 = rstrip(b\\\"\\\\x00\\\") at close/flush\
      \     (default 1)\n    expect_seq_start : int  Expected first seq (default 0).\
      \ Used only for logging/duplicate detection.\n\n    Ports\n    -----\n    in\
      \    : PDU input  (payload only)\n    ctrl  : PDU input  (optional commands:\
      \ b\\\"RESET\\\", b\\\"FLUSH\\\", b\\\"CLOSE\\\")\n    log   : PDU output (optional\
      \ status messages)\n    \"\"\"\n\n    def __init__(self, output_path=\"/tmp/out.txt\"\
      , overwrite=1, strip_zeros_on_close=1, expect_seq_start=0):\n        gr.basic_block.__init__(self,\
      \ name=\"File Source\", in_sig=None, out_sig=None)\n\n        self.output_path\
      \ = str(output_path)\n        self.overwrite = bool(int(overwrite))\n      \
      \  self.strip_zeros_on_close = bool(int(strip_zeros_on_close))\n        self.expect_seq\
      \ = int(expect_seq_start) & 0xFF\n\n        # state\n        self._f = None\n\
      \        self._lock = threading.Lock()\n        self._last_written_seq = None\
      \    # to detect duplicates\n        self._closed = False\n\n        # ports\n\
      \        self.message_port_register_in(pmt.intern('in'))\n        self.set_msg_handler(pmt.intern('in'),\
      \ self._handle_in)\n\n        self.message_port_register_in(pmt.intern('ctrl'))\n\
      \        self.set_msg_handler(pmt.intern('ctrl'), self._handle_ctrl)\n\n   \
      \     self.message_port_register_out(pmt.intern('log'))\n\n    # ----------\
      \ lifecycle ----------\n    def start(self):\n        self._open_file()\n  \
      \      return super().start()\n\n    def stop(self):\n        self._finalize_file(trim=self.strip_zeros_on_close)\n\
      \        return super().stop()\n\n    # ---------- file helpers ----------\n\
      \    def _open_file(self):\n        with self._lock:\n            os.makedirs(os.path.dirname(self.output_path),\
      \ exist_ok=True) if os.path.dirname(self.output_path) else None\n          \
      \  mode = \"wb\" if self.overwrite else \"ab\"\n            try:\n         \
      \       self._f = open(self.output_path, mode)\n                self._closed\
      \ = False\n                self._emit_log(f\"opened:{self.output_path} mode:{mode}\"\
      )\n            except Exception as e:\n                self._emit_log(f\"error_open:{e}\"\
      )\n\n    def _finalize_file(self, trim=True):\n        with self._lock:\n  \
      \          if self._closed:\n                return\n            try:\n    \
      \            if self._f:\n                    self._f.flush()\n            \
      \        self._f.close()\n                    self._f = None\n             \
      \   if trim and os.path.exists(self.output_path):\n                    # trim\
      \ trailing 0x00 bytes added as padding\n                    with open(self.output_path,\
      \ \"rb\") as f:\n                        data = f.read()\n                 \
      \   data = data.rstrip(b\"\\x00\")\n                    with open(self.output_path,\
      \ \"wb\") as f:\n                        f.write(data)\n                self._closed\
      \ = True\n                self._emit_log(\"closed\")\n            except Exception\
      \ as e:\n                self._emit_log(f\"error_close:{e}\")\n\n    # ----------\
      \ message handlers ----------\n    def _handle_ctrl(self, pdu):\n        # CTRL\
      \ payloads: b\"RESET\", b\"FLUSH\", b\"CLOSE\"\n        if not pmt.is_pair(pdu):\
      \ return\n        pl = pmt.cdr(pdu)\n        if not pmt.is_u8vector(pl): return\n\
      \        cmd = bytes(pmt.u8vector_elements(pl)).strip().upper()\n        if\
      \ cmd == b\"RESET\":\n            # truncate and reset seq tracking\n      \
      \      self._finalize_file(trim=False)\n            # reopen fresh (overwrite)\n\
      \            self.overwrite = True\n            self._open_file()\n        \
      \    self._last_written_seq = None\n            self._emit_log(\"reset\")\n\
      \        elif cmd == b\"FLUSH\":\n            # flush & trim zeros once (keeps\
      \ file open by reopening append)\n            self._finalize_file(trim=True)\n\
      \            self.overwrite = False\n            self._open_file()\n       \
      \     self._emit_log(\"flushed\")\n        elif cmd == b\"CLOSE\":\n       \
      \     self._finalize_file(trim=True)\n        else:\n            self._emit_log(f\"\
      unknown_ctrl:{cmd!r}\")\n\n    def _handle_in(self, pdu):\n        if not pmt.is_pair(pdu):\n\
      \            return\n        meta, pl = pmt.car(pdu), pmt.cdr(pdu)\n       \
      \ if not pmt.is_u8vector(pl):\n            return\n        payload = bytes(pmt.u8vector_elements(pl))\n\
      \n        # Expect exactly 32 bytes from crc32_verify_and_ack.out\n        if\
      \ len(payload) != 32:\n            self._emit_log(f\"warn_len:{len(payload)}\
      \ (expected 32)\")\n\n        # Read seq from metadata if present\n        seq\
      \ = None\n        if pmt.is_dict(meta):\n            try:\n                if\
      \ pmt.dict_has_key(meta, pmt.intern(\"seq\")):\n                    seq = int(pmt.to_python(pmt.dict_ref(meta,\
      \ pmt.intern(\"seq\"), pmt.PMT_NIL))) & 0xFF\n            except Exception:\n\
      \                seq = None\n\n        # Duplicate protection (stop-and-wait\
      \ should avoid dupes, but retries might echo)\n        if seq is not None and\
      \ self._last_written_seq is not None and seq == self._last_written_seq:\n  \
      \          self._emit_log(f\"skip_dup_seq:{seq}\")\n            return\n\n \
      \       # Append payload bytes\n        with self._lock:\n            if not\
      \ self._f:\n                self._open_file()\n            try:\n          \
      \      self._f.write(payload)\n                self._f.flush()\n           \
      \     self._last_written_seq = seq if seq is not None else self._last_written_seq\n\
      \            except Exception as e:\n                self._emit_log(f\"error_write:{e}\"\
      )\n                return\n\n        # Light sequencing check (optional)\n \
      \       if seq is not None:\n            if seq != self.expect_seq:\n      \
      \          self._emit_log(f\"seq_out_of_order:got={seq} exp={self.expect_seq}\"\
      )\n                # still accept; update expected next (stop-and-wait increments\
      \ by 1)\n            self.expect_seq = (seq + 1) & 0xFF\n\n    # ----------\
      \ log helper ----------\n    def _emit_log(self, msg: str):\n        try:\n\
      \            m = pmt.make_dict()\n            m = pmt.dict_add(m, pmt.intern(\"\
      file\"), pmt.intern(self.output_path))\n            m = pmt.dict_add(m, pmt.intern(\"\
      event\"), pmt.intern(msg))\n            self.message_port_pub(pmt.intern('log'),\
      \ pmt.cons(m, pmt.PMT_NIL))\n        except Exception:\n            pass\n"
    affinity: ''
    alias: ''
    comment: ''
    expect_seq_start: '0'
    maxoutbuf: '0'
    minoutbuf: '0'
    output_path: '"C:\\Users\\Lenovo\\Downloads\\test_1\\output.txt"'
    overwrite: '1'
    strip_zeros_on_close: '1'
  states:
    _io_cache: "('File Source', 'pdu_payload_to_file', [('output_path', \"'/tmp/out.txt'\"\
      ), ('overwrite', '1'), ('strip_zeros_on_close', '1'), ('expect_seq_start', '0')],\
      \ [('ctrl', 'message', 1), ('in', 'message', 1)], [('log', 'message', 1)], '\\\
      n    PDU Payload \u2192 File\\n    ------------------\\n    Input  PDUs (from\
      \ crc32_verify_and_ack.out): [ PAYLOAD(32B) ] with meta {seq, packet_len=32,\
      \ crc_ok=True}\\n    Action: Appends PAYLOAD to a file, once per new sequence\
      \ number.\\n            On stop (or CTRL \"FLUSH\"), optionally trims trailing\
      \ 0x00 bytes (padding).\\n\\n    Parameters\\n    ----------\\n    output_path\
      \ : str   Path to output file (use r\"D:\\\\path\\\\out.txt\" on Windows)\\\
      n    overwrite   : int   1 = truncate on start, 0 = append if file exists  (default\
      \ 1)\\n    strip_zeros_on_close : int  1 = rstrip(b\"\\\\x00\") at close/flush\
      \     (default 1)\\n    expect_seq_start : int  Expected first seq (default\
      \ 0). Used only for logging/duplicate detection.\\n\\n    Ports\\n    -----\\\
      n    in    : PDU input  (payload only)\\n    ctrl  : PDU input  (optional commands:\
      \ b\"RESET\", b\"FLUSH\", b\"CLOSE\")\\n    log   : PDU output (optional status\
      \ messages)\\n    ', ['output_path', 'overwrite', 'strip_zeros_on_close'])"
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1424, 1324.0]
    rotation: 0
    state: enabled
- name: epy_block_6
  id: epy_block
  parameters:
    _source_code: "from gnuradio import gr\nimport pmt\n\nclass ack_address_filter_rx(gr.basic_block):\n\
      \    \"\"\"\n    ACK Address Filter (RX) with Preamble\n    -------------------------------------\n\
      \    Input PDU payload contains one or more concatenated ACK frames.\n\n   \
      \ New ACK frame format (78 bytes):\n        [ PREAMBLE(32) | DEST(1) | NEXT_SEQ(1)\
      \ | PAYLOAD(40) | CRC32(4) ]\n\n    On match (DEST == my_addr):\n        Output\
      \ stripped ACK (45 bytes):\n           payload = [ NEXT_SEQ(1) | PAYLOAD(40)\
      \ | CRC32(4) ]\n           meta    = { dest_addr=<>, next_seq=<>, ... }\n\n\
      \    On mismatch:\n        Output to 'drop' with reason 'addr_mismatch'\n\n\
      \    Any trailing bytes < FRAME_LEN are ignored.\n    \"\"\"\n\n    def __init__(self,\
      \ my_addr=15, preamble_len=32):\n        gr.basic_block.__init__(self, name=\"\
      Address Filter ACK\",\n                                in_sig=None, out_sig=None)\n\
      \n        self.my_addr = int(my_addr) & 0xFF\n        self.PREAMBLE_LEN = int(preamble_len)\n\
      \n        # Frame (per ACK) = PREAMBLE(32) + DEST(1) + NEXT_SEQ(1) + PAYLOAD(40)\
      \ + CRC32(4)\n        self.FRAME_LEN = self.PREAMBLE_LEN + 1 + 1 + 40 + 4  #\
      \ 32 + 46 = 78\n\n        self.message_port_register_in(pmt.intern('in'))\n\
      \        self.set_msg_handler(pmt.intern('in'), self._handle)\n\n        self.message_port_register_out(pmt.intern('out'))\
      \   # stripped ACK frames\n        self.message_port_register_out(pmt.intern('drop'))\
      \  # non-matching or errors\n\n    def _handle(self, pdu):\n        if not pmt.is_pair(pdu):\n\
      \            return\n        meta, pl = pmt.car(pdu), pmt.cdr(pdu)\n\n     \
      \   if not pmt.is_u8vector(pl):\n            return\n\n        data = list(pmt.u8vector_elements(pl))\n\
      \        n = len(data)\n\n        if n < self.FRAME_LEN:\n            self._emit_drop(meta,\
      \ data, \"short_input\")\n            return\n\n        # Ignore trailing partial\
      \ frames\n        last = n - (n % self.FRAME_LEN)\n\n        for i in range(0,\
      \ last, self.FRAME_LEN):\n            frame = data[i:i + self.FRAME_LEN]  #\
      \ one full ACK frame\n\n            # DEST is right after the preamble\n   \
      \         dest = frame[self.PREAMBLE_LEN]\n\n            if dest != self.my_addr:\n\
      \                self._emit_drop(meta, frame, \"addr_mismatch\", dest_seen=dest)\n\
      \                continue\n\n            # Strip PREAMBLE + DEST \u2192 keep\
      \ [ NEXT_SEQ | PAYLOAD(40) | CRC32(4) ] = 45 bytes\n            stripped = frame[self.PREAMBLE_LEN\
      \ + 1:]\n\n            if len(stripped) < 1 + 40 + 4:\n                self._emit_drop(meta,\
      \ frame, \"short_after_strip\", dest_seen=dest)\n                continue\n\n\
      \            next_seq = stripped[0]\n\n            out_meta = meta\n       \
      \     try:\n                out_meta = pmt.dict_add(out_meta, pmt.intern(\"\
      dest_addr\"),\n                                        pmt.from_long(int(dest)))\n\
      \                out_meta = pmt.dict_add(out_meta, pmt.intern(\"next_seq\"),\n\
      \                                        pmt.from_long(int(next_seq)))\n   \
      \         except Exception:\n                pass\n\n            self.message_port_pub(\n\
      \                pmt.intern('out'),\n                pmt.cons(out_meta, pmt.init_u8vector(len(stripped),\
      \ stripped))\n            )\n\n    def _emit_drop(self, meta, bytes_list, reason,\
      \ dest_seen=None):\n        try:\n            m = pmt.dict_add(meta, pmt.intern(\"\
      drop_reason\"),\n                             pmt.intern(str(reason)))\n   \
      \         if dest_seen is not None:\n                m = pmt.dict_add(m, pmt.intern(\"\
      dest_seen\"),\n                                 pmt.from_long(int(dest_seen)))\n\
      \            v = pmt.init_u8vector(len(bytes_list), bytes_list)\n          \
      \  self.message_port_pub(pmt.intern('drop'), pmt.cons(m, v))\n        except\
      \ Exception:\n            pass\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    my_addr: '12'
    preamble_len: '128'
  states:
    _io_cache: ('Address Filter ACK', 'ack_address_filter_rx', [('my_addr', '15'),
      ('preamble_len', '32')], [('in', 'message', 1)], [('drop', 'message', 1), ('out',
      'message', 1)], "\n    ACK Address Filter (RX) with Preamble\n    -------------------------------------\n    Input
      PDU payload contains one or more concatenated ACK frames.\n\n    New ACK frame
      format (78 bytes):\n        [ PREAMBLE(32) | DEST(1) | NEXT_SEQ(1) | PAYLOAD(40)
      | CRC32(4) ]\n\n    On match (DEST == my_addr):\n        Output stripped ACK
      (45 bytes):\n           payload = [ NEXT_SEQ(1) | PAYLOAD(40) | CRC32(4) ]\n           meta    =
      { dest_addr=<>, next_seq=<>, ... }\n\n    On mismatch:\n        Output to 'drop'
      with reason 'addr_mismatch'\n\n    Any trailing bytes < FRAME_LEN are ignored.\n    ",
      ['my_addr'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [616, 2200.0]
    rotation: 0
    state: enabled
- name: epy_block_8
  id: epy_block
  parameters:
    _source_code: "from gnuradio import gr\nimport pmt\nfrom Crypto.Cipher import\
      \ AES\n\nclass pdu_aes_decrypt(gr.basic_block):\n    \"\"\"\n    PDU AES Decrypt\
      \ (AES-CTR)\n\n    In:\n      - PDU: (meta, payload_bytes)\n             payload\
      \ = NONCE(8 bytes) | CIPHERTEXT\n\n    Out:\n      - PDU: same meta\n      \
      \       payload = PLAINTEXT\n\n    Parameters:\n      key_hex : same key as\
      \ encrypt block\n      verbose : print debug\n    \"\"\"\n\n    def __init__(self,\
      \ key_hex=\"00112233445566778899AABBCCDDEEFF\", verbose=True):\n        gr.basic_block.__init__(self,\n\
      \                                name=\"PDU AES Decrypt (CTR)\",\n         \
      \                       in_sig=None,\n                                out_sig=None)\n\
      \n        self.verbose = bool(verbose)\n        self.set_key_hex(key_hex)\n\n\
      \        self.message_port_register_in(pmt.intern(\"in\"))\n        self.message_port_register_out(pmt.intern(\"\
      out\"))\n        self.set_msg_handler(pmt.intern(\"in\"), self._handle_msg)\n\
      \n    def _log(self, msg):\n        if self.verbose:\n            print(f\"\
      [pdu_aes_decrypt] {msg}\")\n\n    # ---- key handling ----\n    def set_key_hex(self,\
      \ key_hex):\n        key_hex = key_hex.replace(\" \", \"\")\n        try:\n\
      \            key = bytes.fromhex(key_hex)\n        except ValueError:\n    \
      \        raise ValueError(\"key_hex must be valid hex\")\n\n        if len(key)\
      \ not in (16, 24, 32):\n            raise ValueError(\"AES key must be 16, 24,\
      \ or 32 bytes (32/48/64 hex chars)\")\n\n        self._key = key\n        self._log(f\"\
      Key set ({len(key)} bytes)\")\n\n    # ---- message handler ----\n    def _handle_msg(self,\
      \ pdu):\n        if not pmt.is_pair(pdu):\n            return\n\n        meta\
      \ = pmt.car(pdu)\n        pl   = pmt.cdr(pdu)\n\n        if not pmt.is_u8vector(pl):\n\
      \            self._log(\"Ignoring non-u8vector payload\")\n            return\n\
      \n        data = bytes(pmt.u8vector_elements(pl))\n        if len(data) < 8:\n\
      \            self._log(\"Payload too short (no nonce)\")\n            return\n\
      \n        nonce = data[:8]\n        ciphertext = data[8:]\n\n        cipher\
      \ = AES.new(self._key, AES.MODE_CTR, nonce=nonce)\n        plaintext = cipher.decrypt(ciphertext)\n\
      \n        payload_pmt = pmt.init_u8vector(len(plaintext), list(plaintext))\n\
      \        out_pdu = pmt.cons(meta, payload_pmt)\n        self.message_port_pub(pmt.intern(\"\
      out\"), out_pdu)\n\n        self._log(f\"Decrypted PDU: in_len={len(data)},\
      \ out_len={len(plaintext)}\")\n"
    affinity: ''
    alias: ''
    comment: ''
    key_hex: aes_key
    maxoutbuf: '0'
    minoutbuf: '0'
    verbose: 'False'
  states:
    _io_cache: '(''PDU AES Decrypt (CTR)'', ''pdu_aes_decrypt'', [(''key_hex'', "''00112233445566778899AABBCCDDEEFF''"),
      (''verbose'', ''True'')], [(''in'', ''message'', 1)], [(''out'', ''message'',
      1)], ''\n    PDU AES Decrypt (AES-CTR)\n\n    In:\n      - PDU: (meta, payload_bytes)\n             payload
      = NONCE(8 bytes) | CIPHERTEXT\n\n    Out:\n      - PDU: same meta\n             payload
      = PLAINTEXT\n\n    Parameters:\n      key_hex : same key as encrypt block\n      verbose
      : print debug\n    '', [''verbose''])'
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1072, 1384.0]
    rotation: 0
    state: enabled
- name: fec_extended_decoder_0
  id: fec_extended_decoder
  parameters:
    affinity: ''
    alias: ''
    ann: None
    comment: ''
    decoder_list: dec_cc
    maxoutbuf: '0'
    minoutbuf: '0'
    puncpat: '''11'''
    threadtype: capillary
    value: fec_extended_decoder
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [880, 992.0]
    rotation: 0
    state: enabled
- name: fec_generic_encoder_0
  id: fec_generic_encoder
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    encoder: enc_cc
    itype: byte
    maxoutbuf: '0'
    minoutbuf: '0'
    otype: byte
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [144, 648.0]
    rotation: 0
    state: enabled
- name: pdu_pdu_to_tagged_stream_0
  id: pdu_pdu_to_tagged_stream
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    tag: packet_len
    type: byte
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1120, 288.0]
    rotation: 0
    state: enabled
- name: pdu_pdu_to_tagged_stream_0_0
  id: pdu_pdu_to_tagged_stream
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    tag: packet_len
    type: byte
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1936, 1088.0]
    rotation: 0
    state: enabled
- name: pdu_pdu_to_tagged_stream_0_1
  id: pdu_pdu_to_tagged_stream
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    tag: packet_len
    type: byte
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1928, 1184.0]
    rotation: 0
    state: enabled
- name: pdu_pdu_to_tagged_stream_1
  id: pdu_pdu_to_tagged_stream
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    tag: packet_len
    type: byte
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1064, 416.0]
    rotation: 0
    state: enabled
- name: pdu_tagged_stream_to_pdu_0
  id: pdu_tagged_stream_to_pdu
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    tag: packet_len
    type: byte
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [240, 1304.0]
    rotation: 0
    state: enabled
- name: pdu_tagged_stream_to_pdu_0_0
  id: pdu_tagged_stream_to_pdu
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    tag: packet_len
    type: byte
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [336, 2200.0]
    rotation: 0
    state: enabled
- name: qtgui_const_sink_x_0
  id: qtgui_const_sink_x
  parameters:
    affinity: ''
    alias: ''
    alpha1: '1.0'
    alpha10: '1.0'
    alpha2: '1.0'
    alpha3: '1.0'
    alpha4: '1.0'
    alpha5: '1.0'
    alpha6: '1.0'
    alpha7: '1.0'
    alpha8: '1.0'
    alpha9: '1.0'
    autoscale: 'False'
    axislabels: 'True'
    color1: '"blue"'
    color10: '"dark blue"'
    color2: '"red"'
    color3: '"green"'
    color4: '"black"'
    color5: '"cyan"'
    color6: '"magenta"'
    color7: '"yellow"'
    color8: '"dark red"'
    color9: '"dark green"'
    comment: ''
    grid: 'False'
    gui_hint: ''
    label1: ''
    label10: ''
    label2: ''
    label3: ''
    label4: ''
    label5: ''
    label6: ''
    label7: ''
    label8: ''
    label9: ''
    legend: 'True'
    marker1: '0'
    marker10: '0'
    marker2: '0'
    marker3: '0'
    marker4: '0'
    marker5: '0'
    marker6: '0'
    marker7: '0'
    marker8: '0'
    marker9: '0'
    name: '"AFTER SYNC"'
    nconnections: '1'
    size: '1024'
    style1: '0'
    style10: '0'
    style2: '0'
    style3: '0'
    style4: '0'
    style5: '0'
    style6: '0'
    style7: '0'
    style8: '0'
    style9: '0'
    tr_chan: '0'
    tr_level: '0.0'
    tr_mode: qtgui.TRIG_MODE_FREE
    tr_slope: qtgui.TRIG_SLOPE_POS
    tr_tag: '""'
    type: complex
    update_time: '0.10'
    width1: '1'
    width10: '1'
    width2: '1'
    width3: '1'
    width4: '1'
    width5: '1'
    width6: '1'
    width7: '1'
    width8: '1'
    width9: '1'
    xmax: '2'
    xmin: '-2'
    ymax: '2'
    ymin: '-2'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [624, 772.0]
    rotation: 0
    state: enabled
- name: qtgui_const_sink_x_0_0
  id: qtgui_const_sink_x
  parameters:
    affinity: ''
    alias: ''
    alpha1: '1.0'
    alpha10: '1.0'
    alpha2: '1.0'
    alpha3: '1.0'
    alpha4: '1.0'
    alpha5: '1.0'
    alpha6: '1.0'
    alpha7: '1.0'
    alpha8: '1.0'
    alpha9: '1.0'
    autoscale: 'False'
    axislabels: 'True'
    color1: '"blue"'
    color10: '"dark blue"'
    color2: '"red"'
    color3: '"green"'
    color4: '"black"'
    color5: '"cyan"'
    color6: '"magenta"'
    color7: '"yellow"'
    color8: '"dark red"'
    color9: '"dark green"'
    comment: ''
    grid: 'False'
    gui_hint: ''
    label1: ''
    label10: ''
    label2: ''
    label3: ''
    label4: ''
    label5: ''
    label6: ''
    label7: ''
    label8: ''
    label9: ''
    legend: 'True'
    marker1: '0'
    marker10: '0'
    marker2: '0'
    marker3: '0'
    marker4: '0'
    marker5: '0'
    marker6: '0'
    marker7: '0'
    marker8: '0'
    marker9: '0'
    name: '"ACK"'
    nconnections: '1'
    size: '1024'
    style1: '0'
    style10: '0'
    style2: '0'
    style3: '0'
    style4: '0'
    style5: '0'
    style6: '0'
    style7: '0'
    style8: '0'
    style9: '0'
    tr_chan: '0'
    tr_level: '0.0'
    tr_mode: qtgui.TRIG_MODE_FREE
    tr_slope: qtgui.TRIG_SLOPE_POS
    tr_tag: '""'
    type: complex
    update_time: '0.10'
    width1: '1'
    width10: '1'
    width2: '1'
    width3: '1'
    width4: '1'
    width5: '1'
    width6: '1'
    width7: '1'
    width8: '1'
    width9: '1'
    xmax: '2'
    xmin: '-2'
    ymax: '2'
    ymin: '-2'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [696, 1720.0]
    rotation: 0
    state: enabled
- name: qtgui_const_sink_x_1
  id: qtgui_const_sink_x
  parameters:
    affinity: ''
    alias: ''
    alpha1: '1.0'
    alpha10: '1.0'
    alpha2: '1.0'
    alpha3: '1.0'
    alpha4: '1.0'
    alpha5: '1.0'
    alpha6: '1.0'
    alpha7: '1.0'
    alpha8: '1.0'
    alpha9: '1.0'
    autoscale: 'False'
    axislabels: 'True'
    color1: '"blue"'
    color10: '"dark blue"'
    color2: '"red"'
    color3: '"green"'
    color4: '"black"'
    color5: '"cyan"'
    color6: '"magenta"'
    color7: '"yellow"'
    color8: '"dark red"'
    color9: '"dark green"'
    comment: ''
    grid: 'False'
    gui_hint: ''
    label1: ''
    label10: ''
    label2: ''
    label3: ''
    label4: ''
    label5: ''
    label6: ''
    label7: ''
    label8: ''
    label9: ''
    legend: 'True'
    marker1: '0'
    marker10: '0'
    marker2: '0'
    marker3: '0'
    marker4: '0'
    marker5: '0'
    marker6: '0'
    marker7: '0'
    marker8: '0'
    marker9: '0'
    name: '""'
    nconnections: '1'
    size: '1024'
    style1: '0'
    style10: '0'
    style2: '0'
    style3: '0'
    style4: '0'
    style5: '0'
    style6: '0'
    style7: '0'
    style8: '0'
    style9: '0'
    tr_chan: '0'
    tr_level: '0.0'
    tr_mode: qtgui.TRIG_MODE_FREE
    tr_slope: qtgui.TRIG_SLOPE_POS
    tr_tag: '""'
    type: complex
    update_time: '0.10'
    width1: '1'
    width10: '1'
    width2: '1'
    width3: '1'
    width4: '1'
    width5: '1'
    width6: '1'
    width7: '1'
    width8: '1'
    width9: '1'
    xmax: '2'
    xmin: '-2'
    ymax: '2'
    ymin: '-2'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [792, 380.0]
    rotation: 0
    state: enabled
- name: qtgui_freq_sink_x_0
  id: qtgui_freq_sink_x
  parameters:
    affinity: ''
    alias: ''
    alpha1: '1.0'
    alpha10: '1.0'
    alpha2: '1.0'
    alpha3: '1.0'
    alpha4: '1.0'
    alpha5: '1.0'
    alpha6: '1.0'
    alpha7: '1.0'
    alpha8: '1.0'
    alpha9: '1.0'
    autoscale: 'False'
    average: '1.0'
    axislabels: 'True'
    bw: samp_rate
    color1: '"blue"'
    color10: '"dark blue"'
    color2: '"red"'
    color3: '"green"'
    color4: '"black"'
    color5: '"cyan"'
    color6: '"magenta"'
    color7: '"yellow"'
    color8: '"dark red"'
    color9: '"dark green"'
    comment: ''
    ctrlpanel: 'False'
    fc: '0'
    fftsize: '1024'
    freqhalf: 'True'
    grid: 'False'
    gui_hint: ''
    label: Relative Gain
    label1: ''
    label10: ''''''
    label2: ''''''
    label3: ''''''
    label4: ''''''
    label5: ''''''
    label6: ''''''
    label7: ''''''
    label8: ''''''
    label9: ''''''
    legend: 'True'
    maxoutbuf: '0'
    minoutbuf: '0'
    name: '""'
    nconnections: '1'
    norm_window: 'False'
    showports: 'False'
    tr_chan: '0'
    tr_level: '0.0'
    tr_mode: qtgui.TRIG_MODE_FREE
    tr_tag: '""'
    type: complex
    units: dB
    update_time: '0.10'
    width1: '1'
    width10: '1'
    width2: '1'
    width3: '1'
    width4: '1'
    width5: '1'
    width6: '1'
    width7: '1'
    width8: '1'
    width9: '1'
    wintype: window.WIN_BLACKMAN_hARRIS
    ymax: '10'
    ymin: '-140'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [728, 580.0]
    rotation: 0
    state: enabled
- name: qtgui_time_sink_x_0
  id: qtgui_time_sink_x
  parameters:
    affinity: ''
    alias: ''
    alpha1: '1.0'
    alpha10: '1.0'
    alpha2: '1.0'
    alpha3: '1.0'
    alpha4: '1.0'
    alpha5: '1.0'
    alpha6: '1.0'
    alpha7: '1.0'
    alpha8: '1.0'
    alpha9: '1.0'
    autoscale: 'False'
    axislabels: 'True'
    color1: blue
    color10: dark blue
    color2: red
    color3: green
    color4: black
    color5: cyan
    color6: magenta
    color7: yellow
    color8: dark red
    color9: dark green
    comment: 1,2,1,2
    ctrlpanel: 'False'
    entags: 'True'
    grid: 'False'
    gui_hint: 1,2,1,2
    label1: ''
    label10: ''
    label2: ''
    label3: ''
    label4: ''
    label5: ''
    label6: ''
    label7: ''
    label8: ''
    label9: ''
    legend: 'True'
    marker1: '-1'
    marker10: '-1'
    marker2: '-1'
    marker3: '-1'
    marker4: '-1'
    marker5: '-1'
    marker6: '-1'
    marker7: '-1'
    marker8: '-1'
    marker9: '-1'
    name: ''
    nconnections: '1'
    size: '64'
    srate: samp_rate
    stemplot: 'False'
    style1: '1'
    style10: '1'
    style2: '1'
    style3: '1'
    style4: '1'
    style5: '1'
    style6: '1'
    style7: '1'
    style8: '1'
    style9: '1'
    tr_chan: '0'
    tr_delay: '0'
    tr_level: '0.0'
    tr_mode: qtgui.TRIG_MODE_AUTO
    tr_slope: qtgui.TRIG_SLOPE_POS
    tr_tag: '""'
    type: float
    update_time: '0.10'
    width1: '1'
    width10: '1'
    width2: '1'
    width3: '1'
    width4: '1'
    width5: '1'
    width6: '1'
    width7: '1'
    width8: '1'
    width9: '1'
    ylabel: Amplitude
    ymax: '2'
    ymin: '-2'
    yunit: '""'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [640, 1008.0]
    rotation: 0
    state: enabled
- name: virtual_sink_0
  id: virtual_sink
  parameters:
    alias: ''
    comment: ''
    stream_id: channel_tx
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1552, 384.0]
    rotation: 0
    state: enabled
- name: virtual_sink_0_1
  id: virtual_sink
  parameters:
    alias: ''
    comment: ''
    stream_id: r1
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1064, 696.0]
    rotation: 0
    state: enabled
- name: virtual_sink_0_1_0
  id: virtual_sink
  parameters:
    alias: ''
    comment: ''
    stream_id: r2
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1160, 880.0]
    rotation: 0
    state: enabled
- name: virtual_sink_0_1_0_0
  id: virtual_sink
  parameters:
    alias: ''
    comment: ''
    stream_id: r4
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1336, 1864.0]
    rotation: 0
    state: enabled
- name: virtual_sink_1
  id: virtual_sink
  parameters:
    alias: ''
    comment: ''
    stream_id: out
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [960, 1168.0]
    rotation: 0
    state: enabled
- name: virtual_sink_1_0
  id: virtual_sink
  parameters:
    alias: ''
    comment: ''
    stream_id: out1
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1120, 2048.0]
    rotation: 0
    state: enabled
- name: virtual_sink_2
  id: virtual_sink
  parameters:
    alias: ''
    comment: ''
    stream_id: ack_tx
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [2880, 1120.0]
    rotation: 0
    state: enabled
- name: virtual_sink_3
  id: virtual_sink
  parameters:
    alias: ''
    comment: ''
    stream_id: r3
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1136, 1648.0]
    rotation: 0
    state: enabled
- name: virtual_sink_4
  id: virtual_sink
  parameters:
    alias: ''
    comment: ''
    stream_id: ack
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1168, 2128.0]
    rotation: 0
    state: enabled
- name: virtual_sink_5
  id: virtual_sink
  parameters:
    alias: ''
    comment: ''
    stream_id: soapy_sink
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1064, 520.0]
    rotation: 0
    state: enabled
- name: virtual_source_0
  id: virtual_source
  parameters:
    alias: ''
    comment: ''
    stream_id: channel_tx
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [40, 456.0]
    rotation: 0
    state: enabled
- name: virtual_source_0_0
  id: virtual_source
  parameters:
    alias: ''
    comment: ''
    stream_id: soapy_sink
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [56, 720.0]
    rotation: 0
    state: enabled
- name: virtual_source_0_0_0
  id: virtual_source
  parameters:
    alias: ''
    comment: ''
    stream_id: r1
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [56, 920.0]
    rotation: 0
    state: enabled
- name: virtual_source_0_0_0_0
  id: virtual_source
  parameters:
    alias: ''
    comment: ''
    stream_id: r3
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [80, 1872.0]
    rotation: 0
    state: enabled
- name: virtual_source_1
  id: virtual_source
  parameters:
    alias: ''
    comment: ''
    stream_id: r2
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [48, 1096.0]
    rotation: 0
    state: true
- name: virtual_source_1_0
  id: virtual_source
  parameters:
    alias: ''
    comment: ''
    stream_id: r4
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [88, 2056.0]
    rotation: 0
    state: true
- name: virtual_source_2
  id: virtual_source
  parameters:
    alias: ''
    comment: ''
    stream_id: out
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [32, 1312.0]
    rotation: 0
    state: enabled
- name: virtual_source_2_0
  id: virtual_source
  parameters:
    alias: ''
    comment: ''
    stream_id: out1
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [64, 2208.0]
    rotation: 0
    state: enabled
- name: virtual_source_3
  id: virtual_source
  parameters:
    alias: ''
    comment: ''
    stream_id: ack_tx
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [88, 1704.0]
    rotation: 0
    state: enabled
- name: virtual_source_4
  id: virtual_source
  parameters:
    alias: ''
    comment: ''
    stream_id: ack
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [32, 224.0]
    rotation: 0
    state: enabled

connections:
- [blocks_char_to_float_0_0, '0', qtgui_time_sink_x_0, '0']
- [blocks_multiply_const_vxx_0, '0', blocks_throttle2_1, '0']
- [blocks_multiply_const_vxx_0_0, '0', blocks_throttle2_0, '0']
- [blocks_repack_bits_bb_0, '0', virtual_sink_1, '0']
- [blocks_repack_bits_bb_0_0, '0', virtual_sink_1_0, '0']
- [blocks_repack_bits_bb_1, '0', digital_scrambler_bb_0, '0']
- [blocks_repack_bits_bb_2, '0', digital_constellation_modulator_0, '0']
- [blocks_tagged_stream_mux_0, '0', virtual_sink_0, '0']
- [blocks_tagged_stream_mux_0_0, '0', digital_constellation_modulator_0_0, '0']
- [blocks_throttle2_0, '0', virtual_sink_2, '0']
- [blocks_throttle2_1, '0', virtual_sink_5, '0']
- [blocks_unpack_k_bits_bb_0_0, '0', digital_correlate_access_code_xx_ts_0_0, '0']
- [digital_constellation_decoder_cb_0_0, '0', digital_diff_decoder_bb_0_0, '0']
- [digital_constellation_modulator_0, '0', blocks_multiply_const_vxx_0, '0']
- [digital_constellation_modulator_0, '0', qtgui_const_sink_x_1, '0']
- [digital_constellation_modulator_0, '0', qtgui_freq_sink_x_0, '0']
- [digital_constellation_modulator_0_0, '0', blocks_multiply_const_vxx_0_0, '0']
- [digital_constellation_soft_decoder_cf_0, '0', fec_extended_decoder_0, '0']
- [digital_correlate_access_code_xx_ts_0, '0', blocks_repack_bits_bb_0, '0']
- [digital_correlate_access_code_xx_ts_0_0, '0', blocks_repack_bits_bb_0_0, '0']
- [digital_costas_loop_cc_0, '0', digital_constellation_soft_decoder_cf_0, '0']
- [digital_costas_loop_cc_0, '0', qtgui_const_sink_x_0, '0']
- [digital_costas_loop_cc_0_0, '0', digital_constellation_decoder_cb_0_0, '0']
- [digital_costas_loop_cc_0_0, '0', qtgui_const_sink_x_0_0, '0']
- [digital_crc_append_0, out, epy_block_0_0, in]
- [digital_crc_append_0_0, out, epy_block_1_0, in]
- [digital_descrambler_bb_0, '0', digital_correlate_access_code_xx_ts_0, '0']
- [digital_diff_decoder_bb_0_0, '0', digital_map_bb_0_0, '0']
- [digital_linear_equalizer_0, '0', virtual_sink_0_1, '0']
- [digital_linear_equalizer_0_0, '0', virtual_sink_3, '0']
- [digital_map_bb_0_0, '0', virtual_sink_0_1_0_0, '0']
- [digital_protocol_formatter_async_0, header, pdu_pdu_to_tagged_stream_0, pdus]
- [digital_protocol_formatter_async_0, payload, pdu_pdu_to_tagged_stream_1, pdus]
- [digital_protocol_formatter_async_0_0, header, pdu_pdu_to_tagged_stream_0_0, pdus]
- [digital_protocol_formatter_async_0_0, payload, pdu_pdu_to_tagged_stream_0_1, pdus]
- [digital_scrambler_bb_0, '0', fec_generic_encoder_0, '0']
- [digital_symbol_sync_xx_0, '0', digital_linear_equalizer_0, '0']
- [digital_symbol_sync_xx_0_0, '0', digital_linear_equalizer_0_0, '0']
- [epy_block_0_0, out, digital_protocol_formatter_async_0, in]
- [epy_block_1, out, epy_block_4, in]
- [epy_block_10, out, digital_crc_append_0, in]
- [epy_block_11, ack_out, digital_crc_append_0_0, in]
- [epy_block_11, out, epy_block_8, in]
- [epy_block_12, ack_out, epy_block_1, ack_in]
- [epy_block_12, ack_out, virtual_sink_4, '0']
- [epy_block_1_0, out, digital_protocol_formatter_async_0_0, in]
- [epy_block_2, out, epy_block_11, in]
- [epy_block_4, out, epy_block_10, in]
- [epy_block_6, out, blocks_message_debug_0, print]
- [epy_block_6, out, epy_block_12, in]
- [epy_block_8, out, epy_block_1, in]
- [epy_block_8, out, epy_block_5, in]
- [fec_extended_decoder_0, '0', virtual_sink_0_1_0, '0']
- [fec_generic_encoder_0, '0', blocks_repack_bits_bb_2, '0']
- [pdu_pdu_to_tagged_stream_0, '0', blocks_tagged_stream_mux_0, '0']
- [pdu_pdu_to_tagged_stream_0_0, '0', blocks_tagged_stream_mux_0_0, '0']
- [pdu_pdu_to_tagged_stream_0_1, '0', blocks_tagged_stream_mux_0_0, '1']
- [pdu_pdu_to_tagged_stream_1, '0', blocks_tagged_stream_mux_0, '1']
- [pdu_tagged_stream_to_pdu_0, pdus, epy_block_2, in]
- [pdu_tagged_stream_to_pdu_0_0, pdus, epy_block_6, in]
- [virtual_source_0, '0', blocks_repack_bits_bb_1, '0']
- [virtual_source_0_0, '0', digital_symbol_sync_xx_0, '0']
- [virtual_source_0_0_0, '0', digital_costas_loop_cc_0, '0']
- [virtual_source_0_0_0_0, '0', digital_costas_loop_cc_0_0, '0']
- [virtual_source_1, '0', blocks_char_to_float_0_0, '0']
- [virtual_source_1, '0', digital_descrambler_bb_0, '0']
- [virtual_source_1_0, '0', blocks_unpack_k_bits_bb_0_0, '0']
- [virtual_source_2, '0', pdu_tagged_stream_to_pdu_0, '0']
- [virtual_source_2_0, '0', pdu_tagged_stream_to_pdu_0_0, '0']
- [virtual_source_3, '0', digital_symbol_sync_xx_0_0, '0']
- [virtual_source_4, '0', epy_block_10, ack_in]

metadata:
  file_format: 1
  grc_version: 3.10.12.0
